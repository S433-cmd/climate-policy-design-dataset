---
title: "Analysis_IEA_consumer"
author: "Simon Rittershaus"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())

# === Package-Check & Load ===
packages <- c(
  "dplyr", "tidyr", "stringr", "readr", "janitor", "purrr", 
  "arrow", "knitr", "lubridate", "ggplot2", "scales", "forcats", "kableExtra", "patchwork", "ggforce", "lme4", "lmerTest", "mclust", "slider"
)

# install missing packages
installed <- rownames(installed.packages())
to_install <- setdiff(packages, installed)
if (length(to_install) > 0) {
  install.packages(to_install, dependencies = TRUE)
}

# load all packages
lapply(packages, library, character.only = TRUE)
```


# Load data
```{r load dataframes}
library(here)
library(dplyr)

# Repo-relative Pfade (Beispiel: processing/analysis/Input)
input_dir  <- here::here("processing", "analysis", "Input")
output_dir <- here::here("processing", "analysis", "Output")

if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

subs_path <- file.path(input_dir, "collapsed_subsidies_trials_mode_aggregated.RData")
regs_path <- file.path(input_dir, "collapsed_regulations_trials_mode_aggregated.RData")
iea_path  <- file.path(input_dir, "updated_IEA_Database_boolean.RData")

stopifnot(file.exists(subs_path), file.exists(regs_path), file.exists(iea_path))

load(subs_path)
load(regs_path)
load(iea_path)

subs_mode_sorted$id_countryiso_year_url <- as.numeric(subs_mode_sorted$id_countryiso_year_url)
regs_mode_sorted$id_countryiso_year_url <- as.numeric(regs_mode_sorted$id_countryiso_year_url)

regs_mode_sorted <- regs_mode_sorted %>% dplyr::filter(!is.na(policy_name))

iea <- df1_updated %>% dplyr::select("Policy":"New_Added_Technologies")

subs_iea_left <- subs_mode_sorted %>% dplyr::left_join(iea, by = "id_countryiso_year_url")
iea_subs_left <- iea %>% dplyr::left_join(subs_mode_sorted, by = "id_countryiso_year_url")

regs_iea_left <- regs_mode_sorted %>% dplyr::left_join(iea, by = "id_countryiso_year_url")
iea_regs_left <- iea %>% dplyr::left_join(regs_mode_sorted, by = "id_countryiso_year_url")
```


# Numer of policies per country over time
```{r}
all_policies <- bind_rows(
  subs_mode_sorted %>% mutate(dataset = "Subsidy"),
  regs_mode_sorted %>% mutate(dataset = "Regulation")
)

policies_per_country <- all_policies %>%
  group_by(country, dataset) %>%
  summarise(n_policies = n_distinct(id_countryiso_year_url), .groups = "drop")
kable(head(policies_per_country, 20))

policies_per_country_year <- all_policies %>%
  group_by(country, year, dataset) %>%
  summarise(n_policies = n_distinct(id_countryiso_year_url), .groups = "drop")

# Gesamt (Subsidy + Regulation zusammen)
policies_total <- all_policies %>%
  group_by(country, year) %>%
  summarise(n_policies = n_distinct(id_countryiso_year_url), .groups = "drop")

library(knitr)
kable(head(policies_per_country_year, 20))

ggplot(policies_per_country_year,
       aes(x = year, y = n_policies, color = dataset, group = interaction(country, dataset))) +
  geom_line() +
  facet_wrap(~ country, scales = "free_y") +
  labs(title = "Number of policies per country over time",
       x = "Year", y = "Number of policies") +
  theme_minimal()
ggplot(policies_total,
       aes(x = year, y = n_policies, group = country, color = country)) +
  geom_line() +
  labs(title = "Total number of policies per country over time",
       x = "Year", y = "Number of policies") +
  theme_minimal()
```



# 1.2 Across Countries Deskriptive Statistik (LÃ¤nderebene)
## Fiscal Support - Regulation, Consumer - Non-Consumer Shares / Numbers
```{r}
# ------------------------------------------------------------
# Pakete
# ------------------------------------------------------------
library(dplyr)
library(tidyr)
library(stringr)
library(forcats)
library(ggplot2)
library(scales)
library(readr)
library(rlang)        # fÃ¼r sym()
library(kableExtra)   # install.packages("kableExtra")

# ---------- DIN A4 (Portrait) MaÃŸe ----------
A4W <- 8.27  # inches
A4H <- 11.69 # inches

# ------------------------------------------------------------
# (Optional) Daten laden / zusammenbauen
# ------------------------------------------------------------
# load("/mnt/data/collapsed_both_mode_aggregated.RData")
# all_policies <- bind_rows(
#   subs_mode_sorted %>% mutate(dataset = "Subsidy"),
#   regs_mode_sorted %>% mutate(dataset = "Regulation")
# )

# ------------------------------------------------------------
# Spalten finden: country, year
# ------------------------------------------------------------
country_col <- dplyr::case_when(
  "country" %in% names(all_policies) ~ "country",
  "Country" %in% names(all_policies) ~ "Country",
  TRUE ~ NA_character_
)
if (is.na(country_col)) stop("Keine LÃ¤nderspalte gefunden (erwartet 'country' oder 'Country').")

year_col <- dplyr::case_when(
  "year" %in% names(all_policies) ~ "year",
  "Year" %in% names(all_policies) ~ "Year",
  "policy_year" %in% names(all_policies) ~ "policy_year",
  TRUE ~ NA_character_
)
if (is.na(year_col)) stop("Keine Jahresspalte gefunden (z.B. 'year'/'Year'/'policy_year').")

# ------------------------------------------------------------
# SÃ¤uberung + Filter: LÃ¤nder-NA/Leer raus, Jahr <= 2022
# ------------------------------------------------------------
all_policies <- all_policies %>%
  mutate(!!country_col := na_if(trimws(.data[[country_col]]), "")) %>%
  filter(!is.na(.data[[country_col]])) %>%
  filter(.data[[year_col]] <= 2022)

# ------------------------------------------------------------
# Hybrid-Handling: "to_consumer" / "to_structural" / "drop"
# ------------------------------------------------------------
hybrid_policy_handling <- "to_consumer"

# ------------------------------------------------------------
# Hilfsfunktion (KORREKT, ohne Selbstaufruf!)
# ------------------------------------------------------------
derive_target_col <- function(df, hybrid = c("to_structural", "to_consumer", "drop")) {
  hybrid <- match.arg(hybrid)

  candidate_cols <- c("Consumer_Oriented","consumer_oriented","consumer","Consumer","CONSUMER")
  col_present <- candidate_cols[candidate_cols %in% names(df)]
  if (length(col_present) == 0) stop("Keine Consumer/Structural-Variable gefunden.")
  col_use <- col_present[1]

  xv <- tolower(trimws(as.character(df[[col_use]])))

  target <- dplyr::case_when(
    xv %in% c("true","1","yes","y","consumer","cons","c") ~ "Consumer",
    xv %in% c("false","0","no","n","structural","struct","s") ~ "Structural",
    xv %in% c("hybrid","mixed") ~ "Hybrid",
    TRUE ~ NA_character_
  )

  # Hybrid-Behandlung
  if (hybrid == "to_structural") {
    target[target == "Hybrid"] <- "Structural"
  } else if (hybrid == "to_consumer") {
    target[target == "Hybrid"] <- "Consumer"
  } else if (hybrid == "drop") {
    # belasse "Hybrid", wird gleich herausgefiltert
  }

  out <- df
  out$target <- target

  if (hybrid == "drop") {
    out <- out %>% filter(!is.na(target) & target != "Hybrid")
  } else {
    out <- out %>% filter(!is.na(target))
  }
  out
}

# ------------------------------------------------------------
# target ableiten + "Structural" -> "Non-Consumer"
# ------------------------------------------------------------
all_policies_std <- derive_target_col(all_policies, hybrid = hybrid_policy_handling) %>%
  mutate(target = if_else(target == "Structural", "Non-Consumer", target))

# dataset-Werte standardisieren (intern weiter "Subsidy"/"Regulation")
if (!"dataset" %in% names(all_policies_std)) {
  stop("Die Spalte 'dataset' (Subsidy/Regulation) fehlt. Bitte beim bind_rows setzen.")
}
all_policies_std <- all_policies_std %>%
  mutate(dataset = case_when(
    tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
    tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
    TRUE ~ dataset
  ))

# ------------------------------------------------------------
# Segment bauen + gewÃ¼nschte Reihenfolge (Fiscal Support links im Stack)
# ------------------------------------------------------------
# Anzeigename fÃ¼r das Instrument (nur Ausgabe!):
dataset_display <- function(x) ifelse(x == "Subsidy", "Fiscal Support", x)

# 1) GewÃ¼nschte Segment-Reihenfolge fÃ¼r den Stack:
desired_levels <- c(
  "Regulation â€“ Non-Consumer",
  "Regulation â€“ Consumer",
  "Fiscal Support â€“ Non-Consumer",
  "Fiscal Support â€“ Consumer"
)

all_policies_std <- all_policies_std %>%
  mutate(
    segment = paste0(dataset_display(dataset), " â€“ ", target),
    segment = factor(segment, levels = desired_levels, ordered = TRUE)
  )

# ------------------------------------------------------------
# Absolute ZÃ¤hlungen + Anteile
# ------------------------------------------------------------
abs_tbl <- all_policies_std %>%
  count(.data[[country_col]], segment, name = "n") %>%
  complete(.data[[country_col]], segment, fill = list(n = 0)) %>%
  group_by(.data[[country_col]]) %>%
  mutate(total = sum(n, na.rm = TRUE)) %>%
  ungroup()

share_tbl <- abs_tbl %>%
  group_by(.data[[country_col]]) %>%
  mutate(share = ifelse(total > 0, n/total, 0)) %>%
  ungroup() %>%
  mutate(segment = factor(segment, levels = desired_levels, ordered = TRUE))

# ------------------------------------------------------------
# LÃ¤nder sortieren: absteigend nach Gesamt-Fiscal-Support-Anteil
# ------------------------------------------------------------
country_order <- share_tbl %>%
  group_by(across(all_of(country_col))) %>%
  summarise(share_fs_total = sum(share[grepl("^Fiscal Support", segment)], na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(share_fs_total)) %>%
  pull(!!sym(country_col))

share_tbl <- share_tbl %>%
  mutate(!!sym(country_col) := factor(!!sym(country_col), levels = country_order))

# ------------------------------------------------------------
# Plot (100%-Stack, horizontal), Fiscal Support links
# ------------------------------------------------------------
my_legend_order <- c(
  "Fiscal Support â€“ Consumer",
  "Fiscal Support â€“ Non-Consumer",
  "Regulation â€“ Consumer",
  "Regulation â€“ Non-Consumer"
)

p_mix <- ggplot(share_tbl, aes(x = !!sym(country_col), y = share, fill = segment)) +
  geom_col(position = position_stack(reverse = FALSE),
           width = 0.85, color = "white", linewidth = 0.2) +
  coord_flip() +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  scale_fill_manual(
    values = c(
      "Regulation â€“ Consumer"        = "#F08080",# Regulation: helles Rot
      "Regulation â€“ Non-Consumer"    = "#C0392B",# Regulation: dunkleres Rot
      "Fiscal Support â€“ Consumer"    = "#4C9BE8",# FS: helles Blau
      "Fiscal Support â€“ Non-Consumer"= "#1E6BB8" # FS: dunkleres Blau
    ),
    breaks = my_legend_order,
    drop = FALSE,
    name = NULL
  ) +
  labs(
    x = NULL,
    y = "Share (100%)",
    title = "Climate Policy Mix",
    subtitle = paste(
      "Instrument Ã— Target: Fiscal Support/Regulations Ã— Consumer/Non-Consumer.",
      "\nCountries ordered by descending total Fiscal Support share"
    )
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title    = element_text(hjust = 0.5),
    legend.position = "top",
    legend.key.size = unit(0.3, "cm"),
    legend.text     = element_text(size = 8),
    plot.subtitle   = element_text(size = 11, margin = margin(t = 4, b = 6)),
    panel.grid.major.y = element_blank(),
    panel.grid.minor   = element_blank()
  )

print(p_mix)

# ------------------------------------------------------------
# EXPORT (A4-optimiert fÃ¼r LaTeX)
# ------------------------------------------------------------
ggsave("policy_mix_shares_by_country_A4_portrait.pdf",
       p_mix, width = A4W, height = A4H, units = "in", device = cairo_pdf)

ggsave("policy_mix_shares_by_country_A4_portrait.png",
       p_mix, width = A4W, height = A4H, units = "in", dpi = 300)

# ------------------------------------------------------------
# ErgÃ¤nzende Tabelle mit absoluten Werten (breites Format)
# ------------------------------------------------------------
abs_tbl <- all_policies_std %>%
  mutate(segment = factor(segment, levels = desired_levels, ordered = TRUE)) %>%
  count(!!sym(country_col), segment, name = "n") %>%
  group_by(!!sym(country_col)) %>%
  tidyr::complete(
    segment = factor(desired_levels, levels = desired_levels, ordered = TRUE),
    fill = list(n = 0)
  ) %>%
  ungroup() %>%
  group_by(!!sym(country_col)) %>%
  mutate(total = sum(n, na.rm = TRUE)) %>%
  ungroup()

abs_wide <- abs_tbl %>%
  select(!!sym(country_col), segment, n, total) %>%
  mutate(segment = as.character(segment)) %>%
  pivot_wider(names_from = segment, values_from = n, values_fill = 0) %>%
  rename(
    Country                          = !!sym(country_col),
    `Regulation â€“ Consumer`          = `Regulation â€“ Consumer`,
    `Regulation â€“ Non-Consumer`      = `Regulation â€“ Non-Consumer`,
    `Fiscal Support â€“ Consumer`      = `Fiscal Support â€“ Consumer`,
    `Fiscal Support â€“ Non-Consumer`  = `Fiscal Support â€“ Non-Consumer`,
    Total_Policies                   = total
  ) %>%
  arrange(desc(Total_Policies)) %>%
  select(
    Country, Total_Policies,
    `Fiscal Support â€“ Consumer`, `Fiscal Support â€“ Non-Consumer`,
    `Regulation â€“ Consumer`, `Regulation â€“ Non-Consumer`
  )

share_wide <- share_tbl %>%
  select(!!sym(country_col), segment, share) %>%
  mutate(segment = as.character(segment)) %>%
  pivot_wider(names_from = segment, values_from = share, values_fill = 0) %>%
  rename(
    Country                          = !!sym(country_col),
    `Regulation â€“ Consumer`          = `Regulation â€“ Consumer`,
    `Regulation â€“ Non-Consumer`      = `Regulation â€“ Non-Consumer`,
    `Fiscal Support â€“ Consumer`      = `Fiscal Support â€“ Consumer`,
    `Fiscal Support â€“ Non-Consumer`  = `Fiscal Support â€“ Non-Consumer`
  ) %>%
  select(
    Country,
    `Fiscal Support â€“ Consumer`, `Fiscal Support â€“ Non-Consumer`,
    `Regulation â€“ Consumer`, `Regulation â€“ Non-Consumer`
  ) %>%
  mutate(across(-Country, ~ str_replace_all(scales::percent(.x, accuracy = 0.1), "%", "\\\\%"))) %>%
  arrange(match(Country, abs_wide$Country))

# ------------------------------------------------------------
# Header-Texte (mehrzeilig via kableExtra::linebreak)
# ------------------------------------------------------------
hdr_counts <- c(
  "Country",
  "Total\\_Policies",
  linebreak("Fiscal Support\nConsumer", align = "c"),
  linebreak("Fiscal Support\nNon-Consumer", align = "c"),
  linebreak("Regulation\nConsumer", align = "c"),
  linebreak("Regulation\nNon-Consumer", align = "c")
)

hdr_shares <- c(
  "Country",
  linebreak("Fiscal Support\nConsumer (\\%)", align = "c"),
  linebreak("Fiscal Support\nNon-Consumer (\\%)", align = "c"),
  linebreak("Regulation\nConsumer (\\%)", align = "c"),
  linebreak("Regulation\nNon-Consumer (\\%)", align = "c")
)

# ------------------------------------------------------------
# LaTeX-Exporte (Overleaf-ready)
# ------------------------------------------------------------
cap_counts <- "Absolute counts of policy segments by country ($\\leq 2022$)."
cap_shares <- "Shares of policy segments by country ($\\leq 2022$)."

tab_counts_tex <- abs_wide %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE,
      linesep = "",
      caption = cap_counts, label = "tab:policy-mix-counts",
      align = c("l", rep("r", ncol(abs_wide) - 1)),
      escape = FALSE,
      col.names = hdr_counts
  ) %>%
  kable_styling(
    latex_options = c("hold_position","repeat_header","scale_down","striped"),
    stripe_color = "gray!15",
    full_width   = FALSE,
    font_size    = 9
  ) %>%
  column_spec(1, width = "2.5cm") %>%
  column_spec(3:6, width = "2.3cm")

writeLines(tab_counts_tex, "policy_mix_counts_by_country.tex")

tab_shares_tex <- share_wide %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE,
      linesep = "",
      caption = cap_shares, label = "tab:policy-mix-shares",
      align = c("l", rep("r", ncol(share_wide) - 1)),
      escape = FALSE,
      col.names = hdr_shares
  ) %>%
  kable_styling(
    latex_options = c("hold_position","repeat_header","scale_down","striped"),
    stripe_color = "gray!15",
    full_width   = FALSE,
    font_size    = 9
  ) %>%
  column_spec(1, width = "2.5cm") %>%
  column_spec(2:5, width = "2.3cm")

writeLines(tab_shares_tex, "policy_mix_shares_by_country.tex")

# ------------------------------------------------------------
# CSV-Exporte (falls gewÃ¼nscht)
# ------------------------------------------------------------
write_csv(abs_wide,  "policy_mix_counts_by_country.csv")
write_csv(share_wide,"policy_mix_shares_by_country.csv")
# ------------------------------------------------------------
# Consumer vs Non-Consumer NUMBERS (stacked counts, same ordering)
# ------------------------------------------------------------

# Wir nutzen abs_tbl aus dem Shares-Block (gleiches country_order)
# Falls das Objekt nicht im Workspace ist, bitte den Shares-Block vorher ausfÃ¼hren.

abs_tbl_num <- abs_tbl %>%
  mutate(
    segment = factor(segment, levels = desired_levels, ordered = TRUE),
    !!sym(country_col) := factor(.data[[country_col]], levels = country_order)
  )

p_mix_num <- ggplot(abs_tbl_num, aes(x = !!sym(country_col), y = n, fill = segment)) +
  geom_col(position = position_stack(reverse = FALSE),
           width = 0.85, color = "white", linewidth = 0.2) +
  coord_flip() +
  scale_y_continuous(labels = comma_format(accuracy = 1)) +
  scale_fill_manual(
    values = c(
      "Regulation â€“ Consumer"         = "#F08080", # Regulation: helles Rot
      "Regulation â€“ Non-Consumer"     = "#C0392B", # Regulation: dunkleres Rot
      "Fiscal Support â€“ Consumer"     = "#4C9BE8", # FS: helles Blau
      "Fiscal Support â€“ Non-Consumer" = "#1E6BB8"  # FS: dunkleres Blau
    ),
    breaks = my_legend_order,
    drop = FALSE,
    name = NULL
  ) +
  labs(
    x = NULL,
    y = "Number of policies",
    title = "Climate Policy Mix",
    subtitle = paste(
      "Instrument Ã— Target: Fiscal Support/Regulations Ã— Consumer/Non-Consumer.",
      "\nCountries ordered by descending total Fiscal Support share"
    )
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title        = element_text(hjust = 0.5),
    legend.position   = "top",
    legend.key.size   = unit(0.3, "cm"),
    legend.text       = element_text(size = 8),
    plot.subtitle     = element_text(size = 11, margin = margin(t = 4, b = 6)),
    panel.grid.major.y= element_blank(),
    panel.grid.minor  = element_blank()
  )

print(p_mix_num)

# ------------------------------------------------------------
# EXPORT (A4-optimiert)
# ------------------------------------------------------------
ggsave("policy_mix_numbers_by_country_A4_portrait.pdf",
       p_mix_num, width = A4W, height = A4H, units = "in", device = cairo_pdf)

ggsave("policy_mix_numbers_by_country_A4_portrait.png",
       p_mix_num, width = A4W, height = A4H, units = "in", dpi = 300)

# ------------------------------------------------------------
# Side-by-side: Numbers (links) + Shares (rechts), gemeinsame Legende
# ------------------------------------------------------------
library(patchwork)

# Einzeltitel entfernen, damit der gemeinsame Titel sauber angezeigt wird
p_mix_num_clean <- p_mix_num + labs(title = NULL, subtitle = NULL)
p_mix_share_clean <- p_mix + labs(title = NULL, subtitle = NULL)

combo_mix <- (p_mix_num_clean + p_mix_share_clean) +
  plot_layout(widths = c(1, 1), guides = "collect")

# Legende zentriert oben
combo_mix <- combo_mix & theme(
  legend.position      = "top",
  legend.justification = "center",
  legend.box.just      = "center"
)

# Gemeinsamer Titel/Untertitel (identisch zur Einzelausgabe)
combo_mix <- combo_mix + plot_annotation(
  title    = "Climate Policy Mix",
  subtitle = paste(
    "Instrument Ã— Target: Fiscal Support/Regulations Ã— Consumer/Non-Consumer.",
    "\nCountries ordered by Fiscal Support share (ascending)"
  ),
  theme = theme(
    plot.title    = element_text(hjust = 0.5, size = 12, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10)
  )
)

ggsave("policy_mix_numbers_vs_shares_side_by_side_A4.pdf",
       combo_mix, width = A4W, height = A4H, units = "in", device = cairo_pdf)
```


# 1.3 Within-country, across time
## Preparation
```{r plot}
#ðŸ§© Gemeinsame Vorbereitung: Jahres-Shares je Land Ã— Segment
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(rlang)

# Sicherstellen, dass 'segment' korrekt ist
all_policies_std <- all_policies_std %>%
  mutate(
    segment = paste0(dataset, " â€“ ", target),
    segment = factor(segment, levels = desired_levels, ordered = TRUE)
  )

# Jahres-Counts & -Shares pro Land Ã— Segment
yearly <- all_policies_std %>%
  count(!!sym(country_col), !!sym(year_col), segment, name = "n") %>%
  complete(!!sym(country_col), !!sym(year_col), segment, fill = list(n = 0)) %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  mutate(total = sum(n, na.rm = TRUE),
         share = ifelse(total > 0, n / total, NA_real_)) %>%
  ungroup() %>%
  mutate(segment = factor(segment, levels = desired_levels, ordered = TRUE))

# (Optional) LÃ¤nder-Sortierung nach Gesamt-Subsidy-Anteil Ã¼ber die ganze Zeit
country_order_ts <- yearly %>%
  group_by(!!sym(country_col)) %>%
  summarise(subsidy_share_mean = mean(share[grepl("^Subsidy", segment)], na.rm = TRUE),
            .groups = "drop") %>%
  arrange(desc(subsidy_share_mean)) %>%
  pull(!!sym(country_col))

yearly <- yearly %>%
  mutate(!!sym(country_col) := factor(!!sym(country_col), levels = country_order_ts))
#ðŸ”§ Optionale GlÃ¤ttung (3-Jahres-MA) â€“ robust bei kleinen Fallzahlen
# Base-R filter fÃ¼r zentriertes 3er-Mittel (NA an RÃ¤ndern)
# 0) share_ma3 robust berechnen (zentriertes 3-Jahres-Mittel)
yearly <- yearly %>%
  group_by(!!sym(country_col), segment) %>%
  arrange(!!sym(year_col), .by_group = TRUE) %>%
  mutate(
    # nur glÃ¤tten, wenn mind. 3 Beobachtungen vorhanden sind
    share_ma3 = if (dplyr::n() >= 3) as.numeric(stats::filter(share, rep(1/3, 3), sides = 2)) else NA_real_
  ) %>%
  ungroup()
```

### Stacked-Area-Plots Shares ; Numbers, cummulative; Tabels
```{r}
# ===========================================
# Pakete
# ===========================================
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(rlang)
library(ggforce)  # facet_wrap_paginate
library(grid)     # unit()
library(zoo)      # rollmean

# ---------- A4 Portrait MaÃŸe ----------
A4W <- 8.27; A4H <- 11.69   # inches

# ---------- Farbpalette (4 Segmente) ----------
pal_segments <- c(
  "Subsidy â€“ Consumer"        = "#4C9BE8",
  "Subsidy â€“ Non-Consumer"    = "#1E6BB8",
  "Regulation â€“ Consumer"     = "#F08080",
  "Regulation â€“ Non-Consumer" = "#C0392B"
)

# ---------- 0) Smoothing (MA3) + Fallback share_use ----------
yearly_smooth <- yearly %>%
  group_by(!!sym(country_col), segment) %>%
  arrange(!!sym(year_col), .by_group = TRUE) %>%
  mutate(
    share_ma3 = if (dplyr::n() >= 3) as.numeric(stats::filter(share, rep(1/3,3), sides = 2)) else NA_real_,
    share_use = coalesce(share_ma3, share)
  ) %>%
  ungroup()

# ---------- 1) Alphabetische Reihenfolge STABIL setzen ----------
countries_alpha <- yearly_smooth %>%
  distinct(!!sym(country_col)) %>%
  transmute(country_chr = as.character(!!sym(country_col))) %>%
  arrange(country_chr) %>%
  pull(country_chr)

yearly_alpha <- yearly_smooth %>%
  mutate(!!sym(country_col) := factor(as.character(!!sym(country_col)),
                                      levels = countries_alpha, ordered = TRUE))

# ---------- 2) Plot-Generatoren ----------
make_area4 <- function(df, title, subtitle) {
  ggplot(df, aes(x = !!sym(year_col), y = share_use, fill = segment)) +
    geom_area(position = "fill", alpha = 0.9, na.rm = TRUE) +
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0,1)) +
    scale_fill_manual(
      values = pal_segments, name = NULL,
      breaks = c("Subsidy â€“ Consumer","Subsidy â€“ Non-Consumer","Regulation â€“ Consumer","Regulation â€“ Non-Consumer"),
      labels = c("Fiscal Support â€“ Consumer","Fiscal Support â€“ Non-Consumer","Regulation â€“ Consumer","Regulation â€“ Non-Consumer")
    ) +
    labs(
      x = NULL, y = "Share",
      title = title,
      subtitle = subtitle,
      caption = "Each year sums to 100% across four segments (â‰¤ 2022)."
    ) +
    theme_minimal(base_size = 11) +
    theme(
      legend.position = "top",
      legend.key.size = unit(0.32, "cm"),
      legend.text     = element_text(size = 8),
      plot.title      = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle   = element_text(hjust = 0.5),
      strip.text      = element_text(size = 8, lineheight = 0.95),
      panel.grid.minor = element_blank()
    )
}

make_area2 <- function(df, title, subtitle) {
  ggplot(df, aes(x = !!sym(year_col), y = share_use, fill = sr)) +
    geom_area(position = "fill", alpha = 0.9, na.rm = TRUE) +
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0,1)) +
    scale_fill_manual(
      values = c("Subsidy" = "#4C9BE8", "Regulation" = "#C0392B"), name = NULL,
      breaks = c("Subsidy","Regulation"),
      labels = c("Fiscal Support","Regulation")
    ) +
    labs(
      x = NULL, y = "Share",
      title = title,
      subtitle = subtitle,
      caption = "Each year sums to 100% across Fiscal Support vs Regulation (â‰¤ 2022)."
    ) +
    theme_minimal(base_size = 11) +
    theme(
      legend.position = "top",
      legend.key.size = unit(0.32, "cm"),
      legend.text     = element_text(size = 8),
      plot.title      = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle   = element_text(hjust = 0.5),
      strip.text      = element_text(size = 8, lineheight = 0.95),
      panel.grid.minor = element_blank()
    )
}

# ---------- 3) A4 PORTRAIT â€“ Alphabetisch, 4-Segmente ----------
p_area_alpha_base <- make_area4(
  yearly_alpha,
  title    = "Within-country policy mix (stacked area)",
  subtitle = "Shares per year (3-year MA; fallback to raw). Countries in alphabetical order."
)

ncol_portrait <- 3
nrow_portrait <- 4
n_countries   <- length(countries_alpha)
pages_alpha   <- ceiling(n_countries / (ncol_portrait * nrow_portrait))

pdf("stacked_area_alpha_A4_portrait.pdf", width = A4W, height = A4H, useDingbats = FALSE)
for (i in seq_len(pages_alpha)) {
  print(
    p_area_alpha_base +
      ggforce::facet_wrap_paginate(
        vars(!!sym(country_col)),
        ncol = ncol_portrait, nrow = nrow_portrait,
        page = i
      )
  )
}
dev.off()

# ===========================================================
# 4) VARIANTE OHNE Consumer/Non-Consumer: nur Fiscal Support vs Regulation
# ===========================================================
yearly_sr <- yearly %>%
  mutate(sr = ifelse(grepl("^Subsidy", segment), "Subsidy", "Regulation")) %>%
  group_by(!!sym(country_col), !!sym(year_col), sr) %>%
  summarise(share = sum(share, na.rm = TRUE), .groups = "drop_last") %>%
  group_by(!!sym(country_col), sr) %>%
  arrange(!!sym(year_col), .by_group = TRUE) %>%
  mutate(
    share_ma3 = if (dplyr::n() >= 3) as.numeric(stats::filter(share, rep(1/3,3), sides = 2)) else NA_real_,
    share_use = coalesce(share_ma3, share)
  ) %>%
  ungroup() %>%
  mutate(!!sym(country_col) := factor(as.character(!!sym(country_col)),
                                      levels = countries_alpha, ordered = TRUE))

p_area_sr_base <- make_area2(
  yearly_sr,
  title    = "Within-country policy mix (Fiscal Support vs Regulation)",
  subtitle = "Shares per year (3-year MA; fallback to raw). Countries in alphabetical order."
)

pages_sr <- ceiling(n_countries / (ncol_portrait * nrow_portrait))

pdf("stacked_area_SR_alpha_A4_portrait.pdf", width = A4W, height = A4H, useDingbats = FALSE)
for (i in seq_len(pages_sr)) {
  print(
    p_area_sr_base +
      ggforce::facet_wrap_paginate(
        vars(!!sym(country_col)),
        ncol = ncol_portrait, nrow = nrow_portrait,
        page = i
      )
  )
}
dev.off()

# ===========================================================
# 5) ALTERNATIVE SORTIERUNG: absteigend nach mittlerem Fiscal-Support-Anteil (1995â€“2020)
#    (A) 4 Segmente, (B) SR
# ===========================================================
window_min <- 1995
window_max <- 2020

# ---- (A) 4-Segmente: Reihenfolge bestimmen ----
country_order_subsidy <- yearly_smooth %>%                     # (Name bleibt!)
  filter(!!sym(year_col) >= window_min, !!sym(year_col) <= window_max) %>%
  mutate(is_subsidy = grepl("^Subsidy", segment)) %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  summarise(share_subsidy = sum(ifelse(is_subsidy, share_use, 0), na.rm = TRUE),
            .groups = "drop") %>%
  group_by(!!sym(country_col)) %>%
  summarise(mean_subsidy = mean(share_subsidy, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(mean_subsidy)) %>%
  pull(!!sym(country_col))

yearly_subsidy_sorted <- yearly_smooth %>%
  mutate(!!sym(country_col) :=
           factor(as.character(!!sym(country_col)),
                  levels = as.character(country_order_subsidy), ordered = TRUE))

p_area_subsidy_base <- make_area4(
  yearly_subsidy_sorted,
  title    = "Within-country policy mix (stacked area)",
  subtitle = sprintf("Countries ordered by mean Fiscal Support share (%dâ€“%d), 3-year MA (fallback to raw).",
                     window_min, window_max)
)

n_countries_sub <- length(country_order_subsidy)
pages_subsidy <- ceiling(n_countries_sub / (ncol_portrait * nrow_portrait))

pdf("stacked_area_sortedBySubsidy_A4_portrait.pdf", width = A4W, height = A4H, useDingbats = FALSE)
for (i in seq_len(pages_subsidy)) {
  print(
    p_area_subsidy_base +
      ggforce::facet_wrap_paginate(
        vars(!!sym(country_col)),
        ncol = ncol_portrait, nrow = nrow_portrait,
        page = i
      )
  )
}
dev.off()

# ---- (B) SR: Reihenfolge bestimmen ----
country_order_subsidy_SR <- yearly_sr %>%
  filter(!!sym(year_col) >= window_min, !!sym(year_col) <= window_max) %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  summarise(share_subsidy = sum(ifelse(sr == "Subsidy", share_use, 0), na.rm = TRUE),
            .groups = "drop") %>%
  group_by(!!sym(country_col)) %>%
  summarise(mean_subsidy = mean(share_subsidy, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(mean_subsidy)) %>%
  pull(!!sym(country_col))

yearly_sr_sorted <- yearly_sr %>%
  mutate(!!sym(country_col) :=
           factor(as.character(!!sym(country_col)),
                  levels = as.character(country_order_subsidy_SR), ordered = TRUE))

p_area_SR_sorted <- make_area2(
  yearly_sr_sorted,
  title    = "Within-country policy mix (Fiscal Support vs Regulation)",
  subtitle = sprintf("Countries ordered by mean Fiscal Support share (%dâ€“%d), 3-year MA (fallback to raw).",
                     window_min, window_max)
)

n_countries_sr <- length(country_order_subsidy_SR)
pages_sr_sorted <- ceiling(n_countries_sr / (ncol_portrait * nrow_portrait))

pdf("stacked_area_SR_sortedBySubsidy_A4_portrait.pdf", width = A4W, height = A4H, useDingbats = FALSE)
for (i in seq_len(pages_sr_sorted)) {
  print(
    p_area_SR_sorted +
      ggforce::facet_wrap_paginate(
        vars(!!sym(country_col)),
        ncol = ncol_portrait, nrow = nrow_portrait,
        page = i
      )
  )
}
dev.off()

# ============================================================
# Within-country (NUMBERS, kumulativ) â€“ 4 Segmente & (Fiscal Support vs Regulation)
# Sortierung: absteigend nach durchschnittlicher jÃ¤hrlicher Anzahl an Fiscal-Support-Policies
# ============================================================

library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(rlang)
library(ggforce)  # facet_wrap_paginate
library(grid)     # unit()

A4W <- 8.27; A4H <- 11.69

# ---------- Segmentlevels wie im Shares-Teil ----------
pal_segments <- c(
  "Subsidy â€“ Consumer"        = "#4C9BE8",
  "Subsidy â€“ Non-Consumer"    = "#1E6BB8",
  "Regulation â€“ Consumer"     = "#F08080",
  "Regulation â€“ Non-Consumer" = "#C0392B"
)
desired_levels <- names(pal_segments)

# 0) segment sauber halten
all_policies_std <- all_policies_std %>%
  mutate(
    segment = paste0(dataset, " â€“ ", target),
    segment = factor(segment, levels = desired_levels, ordered = TRUE)
  )

# 1) Jahres-COUNTS (vollstÃ¤ndige HÃ¼lle je Land Ã— Jahr Ã— Segment)
years_by_ctry <- all_policies_std %>%
  group_by(!!sym(country_col)) %>%
  summarise(ymin = min(.data[[year_col]], na.rm = TRUE),
            ymax = max(.data[[year_col]], na.rm = TRUE),
            .groups = "drop")

yearly_n <- all_policies_std %>%
  count(!!sym(country_col), !!sym(year_col), segment, name = "n") %>%
  right_join(
    years_by_ctry %>%
      rowwise() %>%
      mutate(year_seq = list(seq.int(ymin, ymax))) %>%
      unnest(year_seq) %>%
      select(!!sym(country_col), !!sym(year_col) := year_seq) %>%
      crossing(segment = factor(desired_levels, levels = desired_levels, ordered = TRUE)),
    by = c(country_col, year_col, "segment")
  ) %>%
  mutate(n = replace_na(n, 0L)) %>%
  arrange(!!sym(country_col), !!sym(year_col), segment)

# 2) Kumulativ (4 Segmente)
yearly_n_cum <- yearly_n %>%
  group_by(!!sym(country_col), segment) %>%
  arrange(!!sym(year_col), .by_group = TRUE) %>%
  mutate(cum_n = cumsum(n)) %>%
  ungroup()

# 3) Kumulativ SR
yearly_sr_n_cum <- yearly_n %>%
  mutate(sr = ifelse(grepl("^Subsidy", segment), "Subsidy", "Regulation")) %>%
  group_by(!!sym(country_col), !!sym(year_col), sr) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop_last") %>%
  group_by(!!sym(country_col), sr) %>%
  arrange(!!sym(year_col), .by_group = TRUE) %>%
  mutate(cum_n = cumsum(n)) %>%
  ungroup()

# 4) Sortierung nach durchschnittlicher jÃ¤hrlicher Fiscal-Support-Anzahl
avg_subsidy_per_year <- yearly_sr_n_cum %>%
  filter(sr == "Subsidy") %>%
  group_by(!!sym(country_col)) %>%
  summarise(mean_subsidy_per_year = mean(n, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(mean_subsidy_per_year)) %>%
  pull(!!sym(country_col))

yearly_n_cum <- yearly_n_cum %>%
  mutate(!!sym(country_col) := factor(!!sym(country_col),
                                      levels = avg_subsidy_per_year, ordered = TRUE))

yearly_sr_n_cum <- yearly_sr_n_cum %>%
  mutate(!!sym(country_col) := factor(!!sym(country_col)),
         !!sym(country_col) := factor(!!sym(country_col),
                                      levels = avg_subsidy_per_year, ordered = TRUE))

# 5) Plot-Generatoren
make_area4_num <- function(df, title, subtitle) {
  ggplot(df, aes(x = !!sym(year_col), y = cum_n, fill = segment)) +
    geom_area(position = "stack", alpha = 0.95, na.rm = TRUE) +
    scale_fill_manual(
      values = pal_segments, name = NULL,
      breaks = c("Subsidy â€“ Consumer","Subsidy â€“ Non-Consumer","Regulation â€“ Consumer","Regulation â€“ Non-Consumer"),
      labels = c("Fiscal Support â€“ Consumer","Fiscal Support â€“ Non-Consumer","Regulation â€“ Consumer","Regulation â€“ Non-Consumer")
    ) +
    labs(
      x = NULL, y = "Cumulative number of policies",
      title = title,
      subtitle = subtitle,
      caption = "Cumulative counts by segment within country; years with no activity are set to 0."
    ) +
    theme_minimal(base_size = 11) +
    theme(
      legend.position = "top",
      legend.key.size = unit(0.32, "cm"),
      legend.text     = element_text(size = 8),
      plot.title      = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle   = element_text(hjust = 0.5),
      strip.text      = element_text(size = 8, lineheight = 0.95),
      panel.grid.minor = element_blank()
    )
}

make_area2_num <- function(df, title, subtitle) {
  ggplot(df, aes(x = !!sym(year_col), y = cum_n, fill = sr)) +
    geom_area(position = "stack", alpha = 0.95, na.rm = TRUE) +
    scale_fill_manual(
      values = c("Subsidy" = "#4C9BE8", "Regulation" = "#C0392B"), name = NULL,
      breaks = c("Subsidy","Regulation"),
      labels = c("Fiscal Support","Regulation")
    ) +
    labs(
      x = NULL, y = "Cumulative number of policies",
      title = title,
      subtitle = subtitle,
      caption = "Cumulative counts by instrument within country; years with no activity are set to 0."
    ) +
    theme_minimal(base_size = 11) +
    theme(
      legend.position = "top",
      legend.key.size = unit(0.32, "cm"),
      legend.text     = element_text(size = 8),
      plot.title      = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle   = element_text(hjust = 0.5),
      strip.text      = element_text(size = 8, lineheight = 0.95),
      panel.grid.minor = element_blank()
    )
}

# 6) Facettierte A4-PDFs
ncol_portrait <- 3
nrow_portrait <- 4

n_ctry <- nlevels(yearly_n_cum[[country_col]])
pages4 <- ceiling(n_ctry / (ncol_portrait * nrow_portrait))

p_area4_num <- make_area4_num(
  yearly_n_cum,
  title    = "Within-country policy mix (numbers, stacked area)",
  subtitle = "Cumulative counts per year; countries ordered by average annual Fiscal Support count (descending)."
)

pdf("stacked_area_numbers_4segments_sortedByMeanSubsidy_A4_portrait.pdf",
    width = A4W, height = A4H, useDingbats = FALSE)
for (i in seq_len(pages4)) {
  print(
    p_area4_num +
      ggforce::facet_wrap_paginate(
        vars(!!sym(country_col)),
        ncol = ncol_portrait, nrow = nrow_portrait, page = i
      )
  )
}
dev.off()

n_ctry2 <- nlevels(yearly_sr_n_cum[[country_col]])
pages2 <- ceiling(n_ctry2 / (ncol_portrait * nrow_portrait))

p_area2_num <- make_area2_num(
  yearly_sr_n_cum,
  title    = "Within-country: Fiscal Support vs Regulation (numbers)",
  subtitle = "Cumulative counts per year; countries ordered by average annual Fiscal Support count (descending)."
)

pdf("stacked_area_numbers_SR_sortedByMeanSubsidy_A4_portrait.pdf",
    width = A4W, height = A4H, useDingbats = FALSE)
for (i in seq_len(pages2)) {
  print(
    p_area2_num +
      ggforce::facet_wrap_paginate(
        vars(!!sym(country_col)),
        ncol = ncol_portrait, nrow = nrow_portrait, page = i
      )
  )
}
dev.off()

### Tabels

# ============================================================
# Pakete
# ============================================================
library(dplyr)
library(tidyr)
library(stringr)
library(rlang)
library(readr)
library(kableExtra)
library(scales)

# ============================================================
# PARAMETER
# ============================================================
# country_col <- "country"   # oder "Country"
# year_col    <- "year"      # oder "Year"/"policy_year"

year_breaks  <- c(-Inf, 1999, 2009, 2015, 2022)
year_labels  <- c("â‰¤1999", "2000â€“2009", "2010â€“2015", "2016â€“2022")
stopifnot(length(year_breaks) - 1 == length(year_labels))

tex1 <- "appendix_table1_SR_allpolicies_by_yeargroup.tex"  # Tabelle 1 (NEU)
csv1 <- "appendix_table1_SR_allpolicies_by_yeargroup.csv"

tex2 <- "appendix_table2_SR_consumer_by_yeargroup.tex"     # Tabelle 2
csv2 <- "appendix_table2_SR_consumer_by_yeargroup.csv"

tex3 <- "appendix_table3_CN_allpolicies_by_yeargroup.tex"  # Tabelle 3
csv3 <- "appendix_table3_CN_allpolicies_by_yeargroup.csv"

# ============================================================
# HILFSFUNKTIONEN
# ============================================================
pct_fmt <- function(x, acc = 0.1) stringr::str_replace_all(scales::percent(x, accuracy = acc), "%", "\\\\%")

make_upper_spanner <- function(year_labels) {
  upper <- c(" " = 1)
  for (g in year_labels) upper[g] <- 2
  upper
}

# LÃ¤nder alphabetisch stabil
countries_alpha <- all_policies_std %>%
  filter(.data[[year_col]] <= 2022) %>%
  distinct(!!sym(country_col)) %>%
  transmute(country_chr = as.character(!!sym(country_col))) %>%
  arrange(country_chr) %>%
  pull(country_chr)

# Daten vereinheitlichen + Yeargroup
with_yeargroup <- all_policies_std %>%
  filter(.data[[year_col]] <= 2022) %>%
  mutate(
    year_group = cut(.data[[year_col]], breaks = year_breaks, labels = year_labels,
                     right = TRUE, include.lowest = TRUE),
    !!sym(country_col) := factor(as.character(.data[[country_col]]),
                                 levels = countries_alpha, ordered = TRUE),
    dataset = case_when(
      tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
      tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
      TRUE ~ dataset
    ),
    target = case_when(
      target %in% c("Non-Consumer","Consumer") ~ target,
      target %in% c("Structural") ~ "Non-Consumer",
      TRUE ~ target
    )
  )

# ============================================================
# GENERISCHE HELFER: Pivot â†’ Durchschnittszeile â†’ Prozent-Format
# ============================================================
add_average_row_and_format <- function(wide_numeric, country_name_col = "Country") {
  avg <- wide_numeric %>%
    summarise(across(-all_of(country_name_col), ~ if (all(is.na(.x))) NA_real_ else mean(.x, na.rm = TRUE)))
  avg[[country_name_col]] <- "Average"
  avg <- avg[, names(wide_numeric)]
  out_num <- bind_rows(wide_numeric, avg)
  out_fmt <- out_num %>%
    mutate(across(-all_of(country_name_col),
                  ~ ifelse(is.finite(.x), pct_fmt(.x, 0.1), "â€“")))
  out_fmt
}

# ============================================================
# TABELLE 1 (NEU): Alle Policies â†’ Subsidy vs Regulation je Jahrgruppe
# ============================================================
tab1_numeric <- with_yeargroup %>%
  filter(!is.na(year_group)) %>%
  count(!!sym(country_col), year_group, dataset, name = "n") %>%
  group_by(!!sym(country_col), year_group) %>%
  mutate(total = sum(n), share = ifelse(total > 0, n / total, NA_real_)) %>%
  ungroup() %>%
  select(!!sym(country_col), year_group, dataset, share) %>%
  mutate(dataset = factor(dataset, levels = c("Subsidy","Regulation"))) %>%
  pivot_wider(names_from = c(year_group, dataset), values_from = share) %>%
  arrange(!!sym(country_col)) %>%
  rename(Country = !!sym(country_col)) %>%
  { # Spaltenordnung: pro Jahrgruppe Subsidy dann Regulation
    yr <- year_labels
    wanted <- c()
    for (g in yr) wanted <- c(wanted, paste0(g, "_Subsidy"), paste0(g, "_Regulation"))
    exist <- intersect(wanted, colnames(.))
    select(., Country, all_of(exist))
  }

# CSV (NUMERIC) unverÃ¤ndert (technische Spaltennamen mit "_Subsidy" bleiben)
write_csv(tab1_numeric, sub(".tex$", "_NUMERIC.csv", tex1))

# Durchschnittszeile + Prozent-Format
tab1 <- add_average_row_and_format(tab1_numeric, country_name_col = "Country")

# >>> Sichtbare Spaltenbezeichnungen fÃ¼r die formatierte CSV auf "Fiscal Support" umstellen
names(tab1) <- sub("_Subsidy$", "_FiscalSupport", names(tab1))

write_csv(tab1, csv1)

# Untere Kopfzeile (sichtbar): "Fiscal Support" statt "Subsidy"
tab1_lower <- c("Country", rep(c("Fiscal Support", "Regulation"), times = length(year_labels)))
tab1_upper <- make_upper_spanner(year_labels)

tab1_tex <- tab1 %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE,
      caption = "T1: All policies â€” shares by year-group (Fiscal Support vs. Regulation).",
      label   = "tab:SR_all_by_yeargroup",
      align   = c("l", rep("r", ncol(tab1) - 1)),
      escape  = FALSE,
      col.names = tab1_lower,
      linesep = "") %>%
  add_header_above(tab1_upper, escape = FALSE) %>%
  kable_styling(latex_options = c("hold_position","repeat_header","striped","scale_down"),
                stripe_color  = "gray!12", full_width = FALSE, font_size = 8) %>%
  column_spec(1, width = "2.0cm") %>%
  column_spec(2:ncol(tab1), width = "1.35cm") %>%
  row_spec(nrow(tab1), bold = TRUE, background = "gray!08")

writeLines(tab1_tex, tex1)

# ============================================================
# TABELLE 2: Consumer-Policies â†’ Subsidy vs Regulation je Jahrgruppe
# ============================================================
tab2_numeric <- with_yeargroup %>%
  filter(target == "Consumer", !is.na(year_group)) %>%
  count(!!sym(country_col), year_group, dataset, name = "n") %>%
  group_by(!!sym(country_col), year_group) %>%
  mutate(total = sum(n), share = ifelse(total > 0, n / total, NA_real_)) %>%
  ungroup() %>%
  select(!!sym(country_col), year_group, dataset, share) %>%
  mutate(dataset = factor(dataset, levels = c("Subsidy","Regulation"))) %>%
  pivot_wider(names_from = c(year_group, dataset), values_from = share) %>%
  arrange(!!sym(country_col)) %>%
  rename(Country = !!sym(country_col)) %>%
  {
    yr <- year_labels
    wanted <- c()
    for (g in yr) wanted <- c(wanted, paste0(g, "_Subsidy"), paste0(g, "_Regulation"))
    exist <- intersect(wanted, colnames(.))
    select(., Country, all_of(exist))
  }

# CSV (NUMERIC) unverÃ¤ndert (technische Spaltennamen mit "_Subsidy" bleiben)
write_csv(tab2_numeric, sub(".tex$", "_NUMERIC.csv", tex2))

tab2 <- add_average_row_and_format(tab2_numeric, country_name_col = "Country")

# >>> Sichtbare Spaltenbezeichnungen fÃ¼r die formatierte CSV auf "Fiscal Support" umstellen
names(tab2) <- sub("_Subsidy$", "_FiscalSupport", names(tab2))

write_csv(tab2, csv2)

tab2_lower <- c("Country", rep(c("Fiscal Support", "Regulation"), times = length(year_labels)))
tab2_upper <- make_upper_spanner(year_labels)

tab2_tex <- tab2 %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE, linesep = "",
      caption = "T2: Consumer policies â€” shares by year-group (Fiscal Support vs. Regulation).",
      label   = "tab:SR_consumer_by_yeargroup",
      align   = c("l", rep("r", ncol(tab2) - 1)),
      escape  = FALSE,
      col.names = tab2_lower) %>%
  add_header_above(tab2_upper, escape = FALSE) %>%
  kable_styling(latex_options = c("hold_position","repeat_header","striped","scale_down"),
                stripe_color  = "gray!12", full_width = FALSE, font_size = 8) %>%
  column_spec(1, width = "2.0cm") %>%
  column_spec(2:ncol(tab2), width = "1.35cm") %>%
  row_spec(nrow(tab2), bold = TRUE, background = "gray!08")

writeLines(tab2_tex, tex2)

# ============================================================
# TABELLE 3: Alle Policies â†’ Consumer vs Non-Consumer je Jahrgruppe
# (hier keine "Subsidy"-Beschriftungen â†’ bleibt unverÃ¤ndert)
# ============================================================
tab3_numeric <- with_yeargroup %>%
  filter(!is.na(year_group)) %>%
  count(!!sym(country_col), year_group, target, name = "n") %>%
  group_by(!!sym(country_col), year_group) %>%
  mutate(total = sum(n), share = ifelse(total > 0, n / total, NA_real_)) %>%
  ungroup() %>%
  select(!!sym(country_col), year_group, target, share) %>%
  mutate(target = factor(target, levels = c("Consumer","Non-Consumer"))) %>%
  pivot_wider(names_from = c(year_group, target), values_from = share) %>%
  arrange(!!sym(country_col)) %>%
  rename(Country = !!sym(country_col)) %>%
  {
    yr <- year_labels
    wanted <- c()
    for (g in yr) wanted <- c(wanted, paste0(g, "_Consumer"), paste0(g, "_Non-Consumer"))
    exist <- intersect(wanted, colnames(.))
    select(., Country, all_of(exist))
  }

write_csv(tab3_numeric, sub(".tex$", "_NUMERIC.csv", tex3))

tab3 <- add_average_row_and_format(tab3_numeric, country_name_col = "Country")
write_csv(tab3, csv3)

tab3_lower <- c("Country", rep(c("Consumer", "Non-Consumer"), times = length(year_labels)))
tab3_upper <- make_upper_spanner(year_labels)

tab3_tex <- tab3 %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE,
      caption = "T3: All policies â€” shares by year-group (Consumer vs. Non-Consumer).",
      label   = "tab:CN_all_by_yeargroup",
      align   = c("l", rep("r", ncol(tab3) - 1)),
      escape  = FALSE,
      col.names = tab3_lower,
      linesep = "") %>%
  add_header_above(tab3_upper, escape = FALSE) %>%
  kable_styling(latex_options = c("hold_position","repeat_header","striped","scale_down"),
                stripe_color  = "gray!12", full_width = FALSE, font_size = 8) %>%
  column_spec(1, width = "2.0cm") %>%
  column_spec(2:ncol(tab3), width = "1.35cm") %>%
  row_spec(nrow(tab3), bold = TRUE, background = "gray!08")

writeLines(tab3_tex, tex3)

# ============================================================
# LaTeX (PrÃ¤ambel):
# \usepackage{booktabs}
# \usepackage{longtable}
# \usepackage{array}
# \usepackage{caption}
# ============================================================
```


# 1.1 Zeitliche VerlÃ¤ufe across countries
```{r}
# ============================================================
# TIME SERIES (1990â€“2022): SR Ã— CN â€” Numbers (per active) & Shares
# Trailing MA3 (align = "right", partial = TRUE)
# Speichert Plots + CSV
# ============================================================

library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(stringr)
library(rlang)
library(readr)
library(zoo)
library(patchwork)

A4W <- 8.27; A4H <- 11.69
stopifnot(exists("all_policies_std"), exists("country_col"), exists("year_col"))

# ---- Helper: trailing MA3 ----
ma3_trailing <- function(x) zoo::rollmean(x, 3, align = "right", fill = NA, partial = TRUE)

# ---- Daten vereinheitlichen + Filter ----
dat <- all_policies_std %>%
  mutate(
    dataset = case_when(
      tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
      tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
      TRUE ~ dataset
    ),
    target = if_else(target == "Structural", "Non-Consumer", target)
  ) %>%
  filter(.data[[year_col]] >= 1990, .data[[year_col]] <= 2022) %>%
  filter(dataset %in% c("Subsidy","Regulation"),
         target  %in% c("Consumer","Non-Consumer")) %>%
  mutate(segment = factor(paste0(dataset, " â€“ ", target),
                          levels = c("Subsidy â€“ Consumer","Subsidy â€“ Non-Consumer",
                                     "Regulation â€“ Consumer","Regulation â€“ Non-Consumer"),
                          ordered = TRUE))

# ---- JahreszÃ¤hlungen je Segment ----
yearly_counts <- yearly_counts <- dat %>%
  count(!!sym(year_col), segment, name = "n") %>%
  complete(!!sym(year_col), segment, fill = list(n = 0)) %>%
  rename(year = !!sym(year_col))

# ---- Coverage: aktive LÃ¤nder/Jahr ----
active_countries <- dat %>%
  distinct(year = .data[[year_col]], country = .data[[country_col]]) %>%
  count(year, name = "n_active_countries")

# ---- Numbers: raw + per active + trailing MA3 ----
yearly_counts_tot <- yearly_counts %>%
  group_by(year) %>%
  summarise(total = sum(n), .groups = "drop") %>%
  left_join(active_countries, by = "year") %>%
  mutate(
    total_per_active = if_else(n_active_countries > 0, total / n_active_countries, NA_real_),
    total_ma3        = ma3_trailing(total),
    per_active_ma3   = ma3_trailing(total_per_active)
  )

yearly_counts_seg <- yearly_counts %>%
  left_join(active_countries, by = "year") %>%
  mutate(
    per_active = if_else(n_active_countries > 0, n / n_active_countries, NA_real_),
    n_ma3      = ma3_trailing(n),
    pa_ma3     = ma3_trailing(per_active)
  )

# ---- Shares pro Jahr (Trailing MA3) ----
yearly_shares <- yearly_counts %>%
  group_by(year) %>%
  mutate(year_total = sum(n, na.rm = TRUE),
         share = if_else(year_total > 0, n / year_total, NA_real_)) %>%
  ungroup() %>%
  group_by(segment) %>%
  arrange(year, .by_group = TRUE) %>%
  mutate(share_ma3 = ma3_trailing(share)) %>%
  ungroup()

# ---- Farben ----
pal_seg <- c(
  "Subsidy â€“ Consumer"        = "#4C9BE8",
  "Subsidy â€“ Non-Consumer"    = "#1E6BB8",
  "Regulation â€“ Consumer"     = "#F08080",
  "Regulation â€“ Non-Consumer" = "#C0392B"
)

# ---- Label-Funktion fÃ¼r die Ausgabe ----
label_seg <- function(vals) {
  stringr::str_replace(vals, regex("^Subsid(y|ies)"), "Fiscal Support")
}

# ---- Plot 1: NUMBERS (per active, MA3) ----
p_num <- ggplot(yearly_counts_seg, aes(x = year, y = pa_ma3, fill = segment)) +
  geom_area(position = "stack", alpha = 0.9, na.rm = TRUE) +
  scale_fill_manual(values = pal_seg, name = NULL, labels = label_seg) +
  labs(
    x = NULL, y = "Policies per active country (MA3)",
    title = "Fiscal Support Ã— Regulations Ã— Consumer/Non-Consumer",
    subtitle = "Numbers per year (trailing 3-year MA), normalized by #active countries"
  ) +
  scale_x_continuous(breaks = pretty) +
  scale_y_continuous(labels = label_number(accuracy = 0.1)) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "top")

# ---- Plot 2: SHARES (MA3) ----
p_share <- ggplot(yearly_shares, aes(x = year, y = share_ma3, fill = segment)) +
  geom_area(position = "fill", alpha = 0.9, na.rm = TRUE) +
  scale_fill_manual(values = pal_seg, name = NULL, labels = label_seg) +
  labs(
    x = NULL, y = "Share (100%, MA3)",
    subtitle = "Share of segments among all policies in a year (trailing 3-year MA)"
  ) +
  scale_x_continuous(breaks = pretty) +
  scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0,1)) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "none")

# ---- Kombi (untereinander) ----
p_comb1 <- p_num / p_share +
  plot_layout(heights = c(3, 2), guides = "collect") &
  theme(legend.position = "top")

print(p_comb1)

# ---- Exporte ----
ggsave("ts_SR_CN_numbers_and_shares_A4.pdf", p_comb1,
       width = A4W, height = A4H, units = "in", device = cairo_pdf)
ggsave("ts_SR_CN_numbers_and_shares_A4.png", p_comb1,
       width = A4W, height = A4H, units = "in", dpi = 300)

write_csv(yearly_counts,       "ts_SR_CN_counts_by_segment_YEAR.csv")
write_csv(yearly_counts_tot,   "ts_SR_CN_counts_TOTAL_YEAR.csv")
write_csv(yearly_counts_seg,   "ts_SR_CN_counts_per_active_by_segment_YEAR.csv")
write_csv(yearly_shares,       "ts_SR_CN_shares_by_segment_YEAR.csv")
write_csv(active_countries,    "ts_SR_CN_active_countries_YEAR.csv")

# ========================= NEW: Yeargroup-Aggregationen (zusÃ¤tzlich) =========================
# Era-Definitionen (Pre-Kyoto, Post-Kyoto, Post-Copenhagen, Paris era)
era_breaks <- c(-Inf, 1997, 2009, 2015, 2022)
era_labels <- c("pre-Kyoto","post-Kyoto","post-Copenhagen","Paris era")

add_yeargroup <- function(df, year_col = "year") {
  df %>%
    mutate(year_group = cut(.data[[year_col]],
                            breaks = era_breaks,
                            labels = era_labels,
                            right = TRUE, include.lowest = TRUE))
}

# Numbers per segment (per-active & MA3 zusammengefasst nach Yeargroup)
ts_SR_CN_counts_YEARGROUP <- yearly_counts_seg %>%
  add_yeargroup() %>%
  group_by(year_group, segment) %>%
  summarise(
    n_total               = sum(n, na.rm = TRUE),
    mean_per_active       = mean(per_active, na.rm = TRUE),
    mean_pa_ma3           = mean(pa_ma3, na.rm = TRUE),
    mean_active_countries = mean(n_active_countries, na.rm = TRUE),
    n_years               = dplyr::n(),
    .groups = "drop"
  )

# Totals (alle Segmente) nach Yeargroup
ts_SR_CN_totals_YEARGROUP <- yearly_counts_tot %>%
  add_yeargroup() %>%
  group_by(year_group) %>%
  summarise(
    total_policies        = sum(total, na.rm = TRUE),
    mean_total_per_active = mean(total_per_active, na.rm = TRUE),
    mean_total_ma3        = mean(total_ma3, na.rm = TRUE),
    mean_per_active_ma3   = mean(per_active_ma3, na.rm = TRUE),
    mean_active_countries = mean(n_active_countries, na.rm = TRUE),
    n_years               = dplyr::n(),
    .groups = "drop"
  )

# Shares (roh & MA3) nach Yeargroup
ts_SR_CN_shares_YEARGROUP <- yearly_shares %>%
  add_yeargroup() %>%
  group_by(year_group, segment) %>%
  summarise(
    mean_share     = mean(share, na.rm = TRUE),
    mean_share_ma3 = mean(share_ma3, na.rm = TRUE),
    n_years        = dplyr::n(),
    .groups = "drop"
  )

# Active countries nach Yeargroup
ts_SR_CN_active_YEARGROUP <- active_countries %>%
  add_yeargroup() %>%
  group_by(year_group) %>%
  summarise(
    mean_active_countries   = mean(n_active_countries, na.rm = TRUE),
    median_active_countries = median(n_active_countries, na.rm = TRUE),
    n_years                 = dplyr::n(),
    .groups = "drop"
  )

# CSV-Exports (Yeargroup)
write_csv(ts_SR_CN_counts_YEARGROUP, "ts_SR_CN_counts_per_active_by_segment_YEARGROUP.csv")
write_csv(ts_SR_CN_totals_YEARGROUP, "ts_SR_CN_counts_TOTAL_YEARGROUP.csv")
write_csv(ts_SR_CN_shares_YEARGROUP, "ts_SR_CN_shares_by_segment_YEARGROUP.csv")
write_csv(ts_SR_CN_active_YEARGROUP, "ts_SR_CN_active_countries_YEARGROUP.csv")
# ======================= END NEW: Yeargroup-Aggregationen =======================
```



# 2. Distributive Impact
## 2.2 Across Countries Consumer vs Non-Consumer Subsidies und Regualtions pooled;
### Shares & Counts
```{r}
# ============================================================
# Two levels (Progressive vs Regressive) â€” SHARES (least regressive on top)
# ============================================================

library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(readr)
library(kableExtra)
library(stringr)
library(rlang)

A4W <- 8.27; A4H <- 11.69

# ----------------- Consumer-only -----------------
cons <- all_policies_std %>%
  filter(target == "Consumer") %>%
  ungroup()

# Sanity-Check der Kategorien
allowed <- c("Lower income","All incomes equally","Higher income","Not applicable (non-consumer)")
subs_lvls <- cons %>% filter(dataset=="Subsidy")    %>% pull(income_group)        %>% unique() %>% {.[!is.na(.)]}
regs_lvls <- cons %>% filter(dataset=="Regulation") %>% pull(income_burden_group) %>% unique() %>% {.[!is.na(.)]}
if (length(bad <- setdiff(subs_lvls, allowed))) warning("Unexpected Subsidy income_group: ", paste(bad, collapse=", "))
if (length(bad <- setdiff(regs_lvls, allowed))) warning("Unexpected Regulation income_burden_group: ", paste(bad, collapse=", "))

# Gemeinsames Roh-Label & non-consumer-FÃ¤lle raus
cons <- cons %>%
  mutate(
    dist_raw = case_when(
      dataset=="Subsidy"    ~ as.character(income_group),
      dataset=="Regulation" ~ as.character(income_burden_group),
      TRUE ~ NA_character_
    ),
    dist_raw = trimws(dist_raw)
  ) %>%
  filter(!is.na(dist_raw), dist_raw != "Not applicable (non-consumer)")

# 2-Level Mapping
cons_v1 <- cons %>%
  mutate(
    dist2 = case_when(
      dataset=="Subsidy"    & dist_raw=="Higher income"                              ~ "Regressive",
      dataset=="Subsidy"    & dist_raw %in% c("Lower income","All incomes equally")  ~ "Progressive",
      dataset=="Regulation" & dist_raw=="Lower income"                               ~ "Regressive",
      dataset=="Regulation" & dist_raw %in% c("All incomes equally","Higher income") ~ "Progressive",
      TRUE ~ NA_character_
    ),
    dist2   = factor(dist2, levels=c("Progressive","Regressive"), ordered=TRUE),
    segment = dist2
  ) %>%
  filter(!is.na(dist2)) %>%
  ungroup()

# Counts, totals, shares
abs_v1 <- cons_v1 %>%
  count(.data[[country_col]], segment, name="n") %>%
  tidyr::complete(.data[[country_col]], segment, fill=list(n=0)) %>%
  group_by(.data[[country_col]]) %>%
  mutate(total = sum(n, na.rm=TRUE)) %>%
  ungroup()

share_v1 <- abs_v1 %>%
  group_by(.data[[country_col]]) %>%
  mutate(share = ifelse(total>0, n/total, 0)) %>%
  ungroup()

# Sortierung: least regressive ON TOP
ord_tbl <- share_v1 %>%
  filter(segment=="Regressive") %>%
  arrange(desc(share))
country_levels <- ord_tbl %>% pull(!!sym(country_col))
share_v1 <- share_v1 %>%
  mutate(!!sym(country_col) := factor(.data[[country_col]], levels = country_levels))

# AktivitÃ¤ts-â€žBaselineâ€œ
totals_country <- cons_v1 %>%
  count(.data[[country_col]], name = "total_weight") %>%
  ungroup() %>%
  mutate(!!sym(country_col) := factor(.data[[country_col]], levels = country_levels)) %>%
  mutate(
    scaled_len = if (dplyr::n_distinct(total_weight) > 1) {
      scales::rescale(total_weight, to = c(0.05, 0.30))
    } else {
      rep(0.12, n())
    }
  )

# Referenzlinie (unweighted country mean)
reg_row_v1 <- share_v1 %>%
  filter(segment=="Regressive") %>%
  select(!!sym(country_col), share)
mean_country_v1 <- mean(reg_row_v1$share, na.rm=TRUE)

# Plot
width_main     <- 0.85
width_baseline <- width_main * 0.4

p_v1 <- ggplot() +
  geom_col(data = share_v1,
           aes(x = !!sym(country_col), y = share, fill = segment),
           width = width_main, color = "white", linewidth = 0.2) +
  geom_hline(yintercept = mean_country_v1, linewidth = 1.0, color = "black") +
  coord_flip(clip = "off") +
  scale_y_continuous(labels = percent_format(accuracy = 1),
                     limits = c(0, 1.02),
                     expand = expansion(mult = c(0, 0.01))) +
  scale_x_discrete(limits = levels(share_v1[[country_col]])) +
  scale_fill_manual(values = c("Progressive"="#4C9BE8","Regressive"="#C0392B"), name=NULL) +
  labs(
    x = NULL, y = "Share (100%)",
    title = "Consumer Policies: Distributive Effects (Fiscal Support + Regulations)",
    subtitle = "Progressive vs Regressive â€” solid line = cross-country mean of regressive share"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust=0.5),
    plot.subtitle = element_text(size = 10),
    legend.position = "top",
    legend.key.size = unit(0.3,"cm"),
    legend.text = element_text(size=9),
    panel.grid.major.y = element_blank(),
    panel.grid.minor   = element_blank()
  )

ggsave("dist2_by_country_A4_portrait.pdf", p_v1, width=A4W, height=A4H, units="in", device=cairo_pdf)
print(p_v1)

# ----------------- Tables (Counts & Shares) -----------------
abs_v1_wide <- abs_v1 %>%
  select(!!sym(country_col), segment, n, total) %>%
  pivot_wider(names_from=segment, values_from=n, values_fill=0) %>%
  rename(Country = !!sym(country_col), Total_Policies = total) %>%
  arrange(match(Country, rev(country_levels)))

share_v1_wide <- share_v1 %>%
  select(!!sym(country_col), segment, share) %>%
  pivot_wider(names_from=segment, values_from=share, values_fill=0) %>%
  rename(Country = !!sym(country_col)) %>%
  mutate(across(-Country, ~ str_replace_all(scales::percent(.x, accuracy=0.1), "%","\\\\%"))) %>%
  arrange(match(Country, abs_v1_wide$Country))

hdr_counts_v1 <- c("Country","Total\\_Policies","Progressive","Regressive")
hdr_shares_v1 <- c("Country","Progressive (\\%)","Regressive (\\%)")
cap_counts_v1 <- "Absolute counts of consumer policies by distributive type (Fiscal Support + Regulations, $\\leq 2022$)."
cap_shares_v1 <- "Shares of consumer policies by distributive type (Fiscal Support + Regulations, $\\leq 2022$)."

tex_counts_v1 <- abs_v1_wide %>%
  kbl(format="latex", booktabs=TRUE, longtable=TRUE, linesep="",
      caption=cap_counts_v1, label="tab:dist2_counts",
      align=c("l", rep("r", ncol(abs_v1_wide)-1)), escape=FALSE, col.names=hdr_counts_v1) %>%
  kable_styling(latex_options=c("hold_position","repeat_header","scale_down","striped"),
                stripe_color="gray!15", full_width=FALSE, font_size=9) %>%
  column_spec(1, width="2.5cm")
writeLines(tex_counts_v1, "dist2_counts_by_country.tex")

tex_shares_v1 <- share_v1_wide %>%
  kbl(format="latex", booktabs=TRUE, longtable=TRUE, linesep="",
      caption=cap_shares_v1, label="tab:dist2_shares",
      align=c("l", rep("r", ncol(share_v1_wide)-1)), escape=FALSE, col.names=hdr_shares_v1) %>%
  kable_styling(latex_options=c("hold_position","repeat_header","scale_down","striped"),
                stripe_color="gray!15", full_width=FALSE, font_size=9) %>%
  column_spec(1, width="2.5cm")
writeLines(tex_shares_v1, "dist2_shares_by_country.tex")

note_v1 <- "Note: Progressive = fiscal support benefiting lower incomes or all equally and regulations burdening higher incomes or all equally. Regressive = fiscal support benefiting higher incomes and regulations burdening lower incomes. Thin black baseline at the bottom of each bar indicates relative portfolio size (total consumer policies per country, normalized to the sample). Solid line = unweighted cross-country mean of regressive shares."
writeLines(note_v1, "dist2_plot_note.txt")

write_csv(abs_v1_wide,  "dist2_counts_by_country.csv")
write_csv(share_v1_wide, "dist2_shares_by_country.csv")


# ============================================================
# Two levels (Progressive vs Regressive) â€” NUMBERS (least regressive on top)
# ============================================================

library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(stringr)
library(rlang)

A4W <- 8.27; A4H <- 11.69

# -> nutzt cons_v1, abs_v1, share_v1 aus dem Shares-Chunk

# ORDER: by REGRESSIVE COUNT (ascending; least on top)
ord_count_v1 <- abs_v1 %>%
  filter(segment=="Regressive") %>%
  arrange(n) %>%
  pull(!!sym(country_col))

abs_v1   <- abs_v1   %>% mutate(!!sym(country_col) := factor(.data[[country_col]], levels = ord_count_v1))
share_v1 <- share_v1 %>% mutate(!!sym(country_col) := factor(.data[[country_col]], levels = ord_count_v1))

# X-Limits
max_total_v1 <- abs_v1 %>% group_by(!!sym(country_col)) %>% summarise(T = sum(n), .groups="drop") %>%
  summarise(mx = max(T, na.rm=TRUE)) %>% pull(mx)
xlim_num_v1 <- c(0, max_total_v1 * 1.05)

# Referenzlinien
reg_counts_v1 <- abs_v1 %>% filter(segment == "Regressive") %>% select(!!sym(country_col), n)
mean_country_count_v1 <- mean(reg_counts_v1$n, na.rm = TRUE)
mean_pooled_count_v1  <- sum(reg_counts_v1$n, na.rm = TRUE) / n_distinct(reg_counts_v1[[country_col]])

p2_num <- ggplot(abs_v1, aes(x = n, y = !!sym(country_col), fill = segment)) +
  geom_col(width = 0.85, color = "white", linewidth = 0.2) +
  geom_vline(xintercept = mean_country_count_v1, linewidth = 1.0, color = "black") +
  geom_vline(xintercept = mean_pooled_count_v1,  linewidth = 0.6, color = "black", linetype = "dashed") +
  scale_x_continuous(limits = xlim_num_v1, expand = expansion(mult = c(0, 0.02))) +
  scale_y_discrete(limits = rev(levels(abs_v1[[country_col]]))) +
  scale_fill_manual(values = c("Progressive"="#4C9BE8","Regressive"="#C0392B"), name=NULL) +
  labs(
    x = "Number of consumer policies",
    y = NULL,
    title = "Consumer Policies: Distributive Effects (counts)",
    subtitle = "Ordered by number of regressive policies (ascending)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust=0.5),
    plot.subtitle = element_text(size = 10),
    legend.position = "top",
    legend.key.size = unit(0.3,"cm"),
    legend.text = element_text(size=9),
    panel.grid.major.y = element_blank(),
    panel.grid.minor   = element_blank()
  )

print(p2_num)
ggsave("dist2_numbers_by_country_A4_portrait.pdf", p2_num, width=A4W, height=A4H, units="in", device=cairo_pdf)

#### Ausgabe Numbers neben Shares
# ============================================================
# Side-by-side layouts (counts LEFT, shares RIGHT) on A4 â€” shared legend
# ============================================================

library(patchwork)

# Einzelplot-Titel/Untertitel entfernen
p2_num_clean <- p2_num + labs(title = NULL, subtitle = NULL)
p_v1_clean   <- p_v1   + labs(title = NULL, subtitle = NULL)

# 1) Basiskombi bauen und Legende sammeln
base2 <- (p2_num_clean + p_v1_clean) + 
  plot_layout(widths = c(5, 3), guides = "collect")

# 2) Legende oben und mittig ausrichten
base2 <- base2 & theme(
  legend.position       = "top",
  legend.justification  = "center",
  legend.box.just       = "center"
)

# 3) Globalen Titel/Untertitel hinzufÃ¼gen (zentriert)
combo2 <- base2 + plot_annotation(
  title    = "Consumer Policies: Distributive Effects (Fiscal Support + Regulations)",
  subtitle = "Progressive vs Regressive â€” Number (left) and Share (right); solid line = cross-country mean",
  theme    = theme(
    plot.title    = element_text(hjust = 0.5, size = 12, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10)
  )
)

ggsave("dist2_counts_vs_shares_side_by_side_A4.pdf",
       combo2, width = A4W, height = A4H, units = "in", device = cairo_pdf)

```

## Gemeinsame Count Tabel S-R-C-NC-R-P

```{r}
# ============================================================
# Add Progressive/Regressive columns to policy_mix_counts_by_country
# (do NOT overwrite existing files)
# ============================================================

# 1) Consumer total aus der policy-mix Tabelle
abs_wide_plus <- abs_wide %>%
  mutate(
    Consumer_Policies = (`Fiscal Support â€“ Consumer` + `Regulation â€“ Consumer`)
  )

# 2) dist2 counts (Progressive/Regressive) anbinden
#    (abs_v1_wide hat: Country, Total_Policies, Progressive, Regressive)
abs_wide_plus <- abs_wide_plus %>%
  left_join(
    abs_v1_wide %>%
      select(Country, Progressive, Regressive) %>%
      mutate(
        Progressive = as.integer(Progressive),
        Regressive  = as.integer(Regressive)
      ),
    by = "Country"
  )

# 3) Face validity: Prog+Reg = Consumer Policies?
abs_wide_plus <- abs_wide_plus %>%
  mutate(
    ProgReg_Sum = coalesce(Progressive, 0L) + coalesce(Regressive, 0L),
    Check_OK    = (ProgReg_Sum == Consumer_Policies),
    Check_Diff  = ProgReg_Sum - Consumer_Policies
  )

# Optional: Diagnose-Liste der ProblemfÃ¤lle
bad_rows <- abs_wide_plus %>% filter(!Check_OK)
if (nrow(bad_rows) > 0) {
  message("WARNING: Face-validity check failed for: ",
          paste(bad_rows$Country, collapse = ", "))
  print(bad_rows %>%
          select(Country, Consumer_Policies, Progressive, Regressive, ProgReg_Sum, Check_Diff))
}

# 4) Ausgabe-Tabelle: Check-Spalten NICHT in LaTeX/CSV (optional)
#    -> Wenn du Check-Spalten nicht exportieren willst, droppe sie:
abs_wide_export <- abs_wide_plus %>%
  select(
    Country, Total_Policies,
    `Fiscal Support â€“ Consumer`, `Fiscal Support â€“ Non-Consumer`,
    `Regulation â€“ Consumer`, `Regulation â€“ Non-Consumer`,
    Progressive, Regressive
  )

# 5) Neue CSV schreiben (alte nicht Ã¼berschreiben)
write_csv(abs_wide_export, "policy_mix_counts_by_country_plus_dist2.csv")

# 6) LaTeX-Export (A4 portrait: mehr Spalten => etwas schmaler + scale_down)
hdr_counts_plus <- c(
  "Country",
  "Total\\_Policies",
  linebreak("Fiscal Support\nConsumer", align = "c"),
  linebreak("Fiscal Support\nNon-Consumer", align = "c"),
  linebreak("Regulation\nConsumer", align = "c"),
  linebreak("Regulation\nNon-Consumer", align = "c"),
  linebreak("Progressive\n(Consumer)", align = "c"),
  linebreak("Regressive\n(Consumer)", align = "c")
)

cap_counts_plus <- "Absolute counts of policy segments by country with progressive/regressive consumer policies ($\\leq 2022$)."

tab_counts_plus_tex <- abs_wide_export %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE,
      linesep = "",
      caption = cap_counts_plus, label = "tab:policy-mix-counts-plus-dist2",
      align = c("l", rep("r", ncol(abs_wide_export) - 1)),
      escape = FALSE,
      col.names = hdr_counts_plus
  ) %>%
  kable_styling(
    latex_options = c("hold_position","repeat_header","scale_down","striped"),
    stripe_color = "gray!15",
    full_width   = FALSE,
    font_size    = 8
  ) %>%
  column_spec(1, width = "2.2cm") %>%
  column_spec(2, width = "1.4cm") %>%
  column_spec(3:8, width = "1.6cm")

writeLines(tab_counts_plus_tex, "policy_mix_counts_by_country_plus_dist2.tex")
```
## Mit Mean, Median, SD

```{r}
# ============================================================
# Add Progressive/Regressive + append Mean/Median/SD rows
# (do NOT overwrite existing files)
# ============================================================

# 1) Consumer total aus der policy-mix Tabelle
abs_wide_plus <- abs_wide %>%
  mutate(
    Consumer_Policies = (`Fiscal Support â€“ Consumer` + `Regulation â€“ Consumer`)
  )

# 2) dist2 counts (Progressive/Regressive) anbinden
abs_wide_plus <- abs_wide_plus %>%
  left_join(
    abs_v1_wide %>%
      select(Country, Progressive, Regressive) %>%
      mutate(
        Progressive = as.integer(Progressive),
        Regressive  = as.integer(Regressive)
      ),
    by = "Country"
  )

# 3) Face validity: Prog+Reg = Consumer Policies?
abs_wide_plus <- abs_wide_plus %>%
  mutate(
    ProgReg_Sum = coalesce(Progressive, 0L) + coalesce(Regressive, 0L),
    Check_OK    = (ProgReg_Sum == Consumer_Policies),
    Check_Diff  = ProgReg_Sum - Consumer_Policies
  )

bad_rows <- abs_wide_plus %>% filter(!Check_OK)
if (nrow(bad_rows) > 0) {
  message("WARNING: Face-validity check failed for: ",
          paste(bad_rows$Country, collapse = ", "))
  print(bad_rows %>%
          select(Country, Consumer_Policies, Progressive, Regressive, ProgReg_Sum, Check_Diff))
}

# 4) Export-Table (ohne Check-Spalten)
abs_wide_export <- abs_wide_plus %>%
  select(
    Country, Total_Policies,
    `Fiscal Support â€“ Consumer`, `Fiscal Support â€“ Non-Consumer`,
    `Regulation â€“ Consumer`, `Regulation â€“ Non-Consumer`,
    Progressive, Regressive
  )

# 5) Drei Summary-Zeilen (Mean/Median/SD) â€“ alles gerundet auf ganze Zahlen
num_cols <- setdiff(names(abs_wide_export), "Country")

mean_row <- abs_wide_export %>%
  summarise(across(all_of(num_cols), ~ round(mean(as.numeric(.x), na.rm = TRUE)))) %>%
  mutate(Country = "Mean") %>%
  select(Country, all_of(num_cols))

median_row <- abs_wide_export %>%
  summarise(across(all_of(num_cols), ~ round(median(as.numeric(.x), na.rm = TRUE)))) %>%
  mutate(Country = "Median") %>%
  select(Country, all_of(num_cols))

sd_row <- abs_wide_export %>%
  summarise(across(all_of(num_cols), ~ round(sd(as.numeric(.x), na.rm = TRUE)))) %>%
  mutate(Country = "SD") %>%
  select(Country, all_of(num_cols))

abs_wide_export_plus_stats <- bind_rows(
  abs_wide_export,
  mean_row, median_row, sd_row
)

# 6) Neue CSV schreiben (alte nicht Ã¼berschreiben)
write_csv(abs_wide_export_plus_stats, "policy_mix_counts_by_country_plus_dist2_with_stats.csv")

# 7) LaTeX-Export (A4 portrait: viele Spalten => font_size runter + scale_down)

hdr_counts_plus <- c(
  "Country",
  "Total\\_Policies",
  linebreak("Fiscal Support\nConsumer", align = "c"),
  linebreak("Fiscal Support\nNon-Consumer", align = "c"),
  linebreak("Regulation\nConsumer", align = "c"),
  linebreak("Regulation\nNon-Consumer", align = "c"),
  linebreak("Regressive\n(Consumer)", align = "c"),
  linebreak("Progressive\n(Consumer)", align = "c")
)

# ---------- SAUBERE ABHEBUNG DER SUMMARY-ROWS ----------
idx_mean   <- nrow(abs_wide_export_plus_stats) - 2
idx_median <- nrow(abs_wide_export_plus_stats) - 1
idx_sd     <- nrow(abs_wide_export_plus_stats)

# ------------------------------------------------------------
# LaTeX-Export (Basis) â€“ ohne Caption und Label
# ------------------------------------------------------------
tab_counts_plus_tex <- abs_wide_export_plus_stats %>%
  # WICHTIG: Spaltenreihenfolge hier vertauscht
  select(
    Country, Total_Policies,
    `Fiscal Support â€“ Consumer`, `Fiscal Support â€“ Non-Consumer`,
    `Regulation â€“ Consumer`, `Regulation â€“ Non-Consumer`,
    Regressive, Progressive
  ) %>%
  kbl(
    format = "latex",
    booktabs = TRUE,
    longtable = TRUE,
    linesep = "",
    align = c("l", rep("r", ncol(abs_wide_export_plus_stats) - 1)),
    escape = FALSE,
    col.names = hdr_counts_plus
  ) %>%
  kable_styling(
    latex_options = c("hold_position","repeat_header","scale_down","striped"),
    stripe_color = "gray!15",
    full_width   = FALSE,
    font_size    = 8
  ) %>%
  column_spec(1, width = "2.2cm") %>%
  column_spec(2, width = "1.4cm") %>%
  column_spec(3:8, width = "1.6cm") %>%
  # ---------- SAUBERE ABHEBUNG DER SUMMARY-ROWS ----------
  # SCHRITT 1: Doppellinie NACH der letzten LÃ¤nderzeile
  row_spec(
    nrow(abs_wide_export_plus_stats) - 3,
    extra_latex_after = "\\addlinespace[0.3em]\\hline\\hline"
  ) %>%
  # SCHRITT 2: Summary-Zeilen fett
  row_spec(idx_mean,   bold = TRUE) %>%  # Mean
  row_spec(idx_median, bold = TRUE) %>%  # Median
  row_spec(idx_sd,     bold = TRUE)       # SD

# Exportieren (nicht Ã¼berschreibend)
writeLines(
  tab_counts_plus_tex,
  "policy_mix_counts_by_country_plus_dist2_with_stats.tex"
)
# Exportieren
```


## 2.1 Zeitliche VerlÃ¤ufe across countries
```{r}
# ============================================================
# TIME SERIES (1990â€“2022): Distributive (Consumer-only)
# 2-Klassen & 3-Klassen â€” Numbers per active (MA3) + Shares (MA3)
# ============================================================

library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(rlang)
library(readr)
library(zoo)
library(patchwork)

A4W <- 8.27; A4H <- 11.69
stopifnot(exists("all_policies_std"), exists("country_col"), exists("year_col"))

ma3_trailing <- function(x) zoo::rollmean(x, 3, align = "right", fill = NA, partial = TRUE)

# -- Consumer-only & Vereinheitlichung --
base_cons <- all_policies_std %>%
  mutate(dataset = case_when(
    tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
    tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
    TRUE ~ dataset
  )) %>%
  filter(.data[[year_col]] >= 1990, .data[[year_col]] <= 2022) %>%
  filter(target == "Consumer", dataset %in% c("Subsidy","Regulation"))

# -- Roh-Label --
cons_map <- base_cons %>%
  mutate(
    dist_raw = case_when(
      dataset == "Subsidy"    ~ as.character(income_group),
      dataset == "Regulation" ~ as.character(income_burden_group),
      TRUE ~ NA_character_
    ),
    dist_raw = trimws(dist_raw)
  ) %>%
  filter(!is.na(dist_raw), dist_raw != "Not applicable (non-consumer)")

# -- 2 Klassen --
cons2 <- cons_map %>%
  mutate(
    dist2 = case_when(
      dataset == "Subsidy"    & dist_raw == "Higher income"                              ~ "Regressive",
      dataset == "Subsidy"    & dist_raw %in% c("Lower income","All incomes equally")    ~ "Progressive",
      dataset == "Regulation" & dist_raw == "Lower income"                               ~ "Regressive",
      dataset == "Regulation" & dist_raw %in% c("All incomes equally","Higher income")   ~ "Progressive",
      TRUE ~ NA_character_
    ),
    segment = factor(dist2, levels = c("Progressive","Regressive"), ordered = TRUE)
  ) %>% filter(!is.na(segment))

# -- 3 Klassen --
cons3 <- cons_map %>%
  mutate(
    dist3 = case_when(
      dataset == "Subsidy"    & dist_raw == "Higher income" ~ "Regressive",
      dataset == "Regulation" & dist_raw == "Lower income"  ~ "Regressive",
      dist_raw == "All incomes equally"                     ~ "Progressive",
      dataset == "Subsidy"    & dist_raw == "Lower income"  ~ "Targeting",
      dataset == "Regulation" & dist_raw == "Higher income" ~ "Targeting",
      TRUE ~ NA_character_
    ),
    segment = factor(dist3, levels = c("Progressive","Targeting","Regressive"), ordered = TRUE)
  ) %>% filter(!is.na(segment))

# -- Helper: TS mit trailing MA3 & per-active --
build_ts <- function(df) {
  yc <- df %>%
    count(!!sym(year_col), segment, name = "n") %>%
    complete(!!sym(year_col), segment, fill = list(n = 0)) %>%
    rename(year = !!sym(year_col))

  act <- df %>%
    distinct(year = .data[[year_col]], country = .data[[country_col]]) %>%
    count(year, name = "n_active_countries")

  yc2 <- yc %>%
    left_join(act, by = "year") %>%
    mutate(
      per_active = if_else(n_active_countries > 0, n / n_active_countries, NA_real_),
      n_ma3      = ma3_trailing(n),
      pa_ma3     = ma3_trailing(per_active)
    )

  tot <- yc %>%
    group_by(year) %>% summarise(total = sum(n), .groups = "drop") %>%
    left_join(act, by = "year") %>%
    mutate(
      total_per_active = if_else(n_active_countries > 0, total / n_active_countries, NA_real_),
      total_ma3        = ma3_trailing(total),
      per_active_ma3   = ma3_trailing(total_per_active)
    )

  ys <- yc %>%
    group_by(year) %>%
    mutate(total = sum(n, na.rm = TRUE),
           share = if_else(total > 0, n/total, NA_real_)) %>%
    ungroup() %>%
    group_by(segment) %>%
    arrange(year, .by_group = TRUE) %>%
    mutate(share_ma3 = ma3_trailing(share)) %>%
    ungroup()

  list(y_counts = yc2, y_totals = tot, y_shares = ys, active = act)
}

ts2 <- build_ts(cons2)
ts3 <- build_ts(cons3)

pal2 <- c("Progressive"="#4C9BE8","Regressive"="#C0392B")
pal3 <- c("Progressive"="#4C9BE8","Targeting"="#F5A623","Regressive"="#C0392B")

# -- 2 Klassen --
p2_num <- ggplot(ts2$y_counts, aes(x = year, y = pa_ma3, fill = segment)) +
  geom_area(position = "stack", alpha = 0.9, na.rm = TRUE) +
  scale_fill_manual(values = pal2, name = NULL) +
  labs(x=NULL, y="Policies per active country (MA3)",
       title="Distributive Effects (Consumer): 2 classes",
       subtitle="Numbers per year (trailing 3-year MA), normalized by #active countries") +
  scale_x_continuous(breaks = pretty) +
  theme_minimal(base_size = 11) +
  theme(legend.position="top")

p2_share <- ggplot(ts2$y_shares, aes(x = year, y = share_ma3, fill = segment)) +
  geom_area(position = "fill", alpha = 0.9, na.rm = TRUE) +
  scale_fill_manual(values = pal2, name = NULL) +
  labs(x=NULL, y="Share (100%, MA3)",
       subtitle="Share among consumer policies per year (trailing 3-year MA)") +
  scale_x_continuous(breaks = pretty) +
  scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0,1)) +
  theme_minimal(base_size = 11) +
  theme(legend.position="none")

p_comb2 <- p2_num / p2_share + plot_layout(heights = c(3,2), guides = "collect") &
  theme(legend.position="top")

print(p_comb2)
ggsave("ts_dist2_numbers_and_shares_A4.pdf", p_comb2,
       width = A4W, height = A4H, units = "in", device = cairo_pdf)
ggsave("ts_dist2_numbers_and_shares_A4.png", p_comb2,
       width = A4W, height = A4H, units = "in", dpi = 300)

# -- 3 Klassen --
p3_num <- ggplot(ts3$y_counts, aes(x = year, y = pa_ma3, fill = segment)) +
  geom_area(position = "stack", alpha = 0.9, na.rm = TRUE) +
  scale_fill_manual(values = pal3, name = NULL) +
  labs(x=NULL, y="Policies per active country (MA3)",
       title="Distributive Effects (Consumer): 3 classes",
       subtitle="Numbers per year (trailing 3-year MA), normalized by #active countries") +
  scale_x_continuous(breaks = pretty) +
  theme_minimal(base_size = 11) +
  theme(legend.position="top")

p3_share <- ggplot(ts3$y_shares, aes(x = year, y = share_ma3, fill = segment)) +
  geom_area(position = "fill", alpha = 0.9, na.rm = TRUE) +
  scale_fill_manual(values = pal3, name = NULL) +
  labs(x=NULL, y="Share (100%, MA3)",
       subtitle="Share among consumer policies per year (trailing 3-year MA)") +
  scale_x_continuous(breaks = pretty) +
  scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0,1)) +
  theme_minimal(base_size = 11) +
  theme(legend.position="none")

p_comb3 <- p3_num / p3_share + plot_layout(heights = c(3,2), guides = "collect") &
  theme(legend.position="top")

print(p_comb3)
ggsave("ts_dist3_numbers_and_shares_A4.pdf", p_comb3,
       width = A4W, height = A4H, units = "in", device = cairo_pdf)
ggsave("ts_dist3_numbers_and_shares_A4.png", p_comb3,
       width = A4W, height = A4H, units = "in", dpi = 300)

# ========================= NEW: Yeargroup-Aggregationen (zusÃ¤tzlich) =========================
# Era-Definitionen (Pre-Kyoto, Post-Kyoto, Post-Copenhagen, Paris era)
era_breaks <- c(-Inf, 1997, 2009, 2015, 2022)
era_labels <- c("pre-Kyoto","post-Kyoto","post-Copenhagen","Paris era")

add_yeargroup <- function(df, year_col = "year") {
  df %>%
    mutate(year_group = cut(.data[[year_col]],
                            breaks = era_breaks,
                            labels = era_labels,
                            right = TRUE, include.lowest = TRUE))
}

# ---- dist2: Yeargroup-Tabellen ----
ts2_counts_YG <- ts2$y_counts %>%
  add_yeargroup() %>%
  group_by(year_group, segment) %>%
  summarise(
    n_total             = sum(n, na.rm = TRUE),
    mean_per_active     = mean(per_active, na.rm = TRUE),
    mean_pa_ma3         = mean(pa_ma3, na.rm = TRUE),
    mean_active_countries = mean(n_active_countries, na.rm = TRUE),
    n_years             = dplyr::n(),
    .groups = "drop"
  )

ts2_totals_YG <- ts2$y_totals %>%
  add_yeargroup() %>%
  group_by(year_group) %>%
  summarise(
    total_policies          = sum(total, na.rm = TRUE),
    mean_total_per_active   = mean(total_per_active, na.rm = TRUE),
    mean_total_ma3          = mean(total_ma3, na.rm = TRUE),
    mean_per_active_ma3     = mean(per_active_ma3, na.rm = TRUE),
    mean_active_countries   = mean(n_active_countries, na.rm = TRUE),
    n_years                 = dplyr::n(),
    .groups = "drop"
  )

ts2_shares_YG <- ts2$y_shares %>%
  add_yeargroup() %>%
  group_by(year_group, segment) %>%
  summarise(
    mean_share      = mean(share, na.rm = TRUE),
    mean_share_ma3  = mean(share_ma3, na.rm = TRUE),
    n_years         = dplyr::n(),
    .groups = "drop"
  )

ts2_active_YG <- ts2$active %>%
  add_yeargroup() %>%
  group_by(year_group) %>%
  summarise(
    mean_active_countries   = mean(n_active_countries, na.rm = TRUE),
    median_active_countries = median(n_active_countries, na.rm = TRUE),
    n_years                 = dplyr::n(),
    .groups = "drop"
  )

# ---- dist3: Yeargroup-Tabellen ----
ts3_counts_YG <- ts3$y_counts %>%
  add_yeargroup() %>%
  group_by(year_group, segment) %>%
  summarise(
    n_total             = sum(n, na.rm = TRUE),
    mean_per_active     = mean(per_active, na.rm = TRUE),
    mean_pa_ma3         = mean(pa_ma3, na.rm = TRUE),
    mean_active_countries = mean(n_active_countries, na.rm = TRUE),
    n_years             = dplyr::n(),
    .groups = "drop"
  )

ts3_totals_YG <- ts3$y_totals %>%
  add_yeargroup() %>%
  group_by(year_group) %>%
  summarise(
    total_policies          = sum(total, na.rm = TRUE),
    mean_total_per_active   = mean(total_per_active, na.rm = TRUE),
    mean_total_ma3          = mean(total_ma3, na.rm = TRUE),
    mean_per_active_ma3     = mean(per_active_ma3, na.rm = TRUE),
    mean_active_countries   = mean(n_active_countries, na.rm = TRUE),
    n_years                 = dplyr::n(),
    .groups = "drop"
  )

ts3_shares_YG <- ts3$y_shares %>%
  add_yeargroup() %>%
  group_by(year_group, segment) %>%
  summarise(
    mean_share      = mean(share, na.rm = TRUE),
    mean_share_ma3  = mean(share_ma3, na.rm = TRUE),
    n_years         = dplyr::n(),
    .groups = "drop"
  )

ts3_active_YG <- ts3$active %>%
  add_yeargroup() %>%
  group_by(year_group) %>%
  summarise(
    mean_active_countries   = mean(n_active_countries, na.rm = TRUE),
    median_active_countries = median(n_active_countries, na.rm = TRUE),
    n_years                 = dplyr::n(),
    .groups = "drop"
  )
# ======================= END NEW: Yeargroup-Aggregationen =======================

# -- CSV-Exports --
write_csv(ts2$y_counts, "ts_dist2_counts_per_active_by_segment_YEAR.csv")
write_csv(ts2$y_totals, "ts_dist2_counts_TOTAL_YEAR.csv")
write_csv(ts2$y_shares, "ts_dist2_shares_by_segment_YEAR.csv")
write_csv(ts2$active,   "ts_dist2_active_countries_YEAR.csv")

write_csv(ts3$y_counts, "ts_dist3_counts_per_active_by_segment_YEAR.csv")
write_csv(ts3$y_totals, "ts_dist3_counts_TOTAL_YEAR.csv")
write_csv(ts3$y_shares, "ts_dist3_shares_by_segment_YEAR.csv")
write_csv(ts3$active,   "ts_dist3_active_countries_YEAR.csv")

# -- CSV-Exports (NEW): Yeargroup-Dateien zusÃ¤tzlich --
write_csv(ts2_counts_YG, "ts_dist2_counts_per_active_by_segment_YEARGROUP.csv")
write_csv(ts2_totals_YG, "ts_dist2_counts_TOTAL_YEARGROUP.csv")
write_csv(ts2_shares_YG, "ts_dist2_shares_by_segment_YEARGROUP.csv")
write_csv(ts2_active_YG, "ts_dist2_active_countries_YEARGROUP.csv")

write_csv(ts3_counts_YG, "ts_dist3_counts_per_active_by_segment_YEARGROUP.csv")
write_csv(ts3_totals_YG, "ts_dist3_counts_TOTAL_YEARGROUP.csv")
write_csv(ts3_shares_YG, "ts_dist3_shares_by_segment_YEARGROUP.csv")
write_csv(ts3_active_YG, "ts_dist3_active_countries_YEARGROUP.csv")
```

## 1.1 / 2.1 Zeitliche Tests: Regulations, Consumer-orientation, Progressivness

```{r}
# ============================================================
# ZEITLICHE TESTS (angepasst): Fiscal Support Labels + 2 getrennte Grafiken
# ============================================================

library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(rlang)
library(lme4)
library(lmerTest)
library(readr)
library(zoo)
library(patchwork)

# ---- Parameter/Defaults (unverÃ¤ndert) ----
if (!exists("MIN_ACTIVE")) MIN_ACTIVE <- 18
if (!exists("country_col") || !exists("year_col"))
  stop("Bitte 'country_col' und 'year_col' im Workspace haben.")
if (!exists("all_policies_std"))
  stop("Bitte 'all_policies_std' (aufbereitet) im Workspace haben.")

ROBUST_MIN_YEAR <- 1999
ROBUST_MAX_YEAR <- 2019   # <== 1999â€“2019
ALPHA <- 0.05

A4W <- 8.27; A4H <- 11.69

# ---- Helper: trailing MA3 (unverÃ¤ndert) ----
ma3_trailing <- function(x) zoo::rollmean(x, 3, align = "right", fill = NA, partial = TRUE)

# ---- Abdeckung (aktive LÃ¤nder/Jahr) (unverÃ¤ndert) ----
active_by_year <- all_policies_std %>%
  distinct(year = .data[[year_col]], country = .data[[country_col]]) %>%
  count(year, name = "n_active")

# ---- 1) Country-Year SHARES (SR, CN) inkl. trailing MA3 (Basis unverÃ¤ndert) ----
# SR: Regulation-Share je Land & Jahr (Subs+Regs) â€” Basis
sr_base <- all_policies_std %>%
  mutate(dataset = case_when(
    tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
    tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
    TRUE ~ dataset
  )) %>%
  filter(.data[[year_col]] >= 1990, .data[[year_col]] <= 2022) %>%
  filter(dataset %in% c("Subsidy","Regulation")) %>%
  count(!!sym(country_col), !!sym(year_col), dataset, name = "n") %>%
  complete(!!sym(country_col), !!sym(year_col), dataset, fill = list(n = 0)) %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  mutate(total = sum(n), share = if_else(total > 0, n/total, NA_real_)) %>%
  ungroup() %>%
  rename(country = !!sym(country_col), year = !!sym(year_col)) %>%
  arrange(country, year) %>%
  group_by(country, dataset) %>%
  mutate(share_ma3 = ma3_trailing(share)) %>%
  ungroup()

# FÃ¼r den 2-Linien-Plot: sowohl Regulation- als auch Fiscal-Support-Linie
sr_cy <- sr_base %>%
  mutate(dim = if_else(dataset == "Regulation", "Regulation share", "Fiscal Support share")) %>%
  select(country, year, dim, share, share_ma3)

# CN: Consumer-Share je Land & Jahr (Consumer vs Non-Consumer) â€” Basis
cn_base <- all_policies_std %>%
  mutate(target = if_else(target == "Structural", "Non-Consumer", target)) %>%
  filter(.data[[year_col]] >= 1990, .data[[year_col]] <= 2022) %>%
  filter(target %in% c("Consumer","Non-Consumer")) %>%
  count(!!sym(country_col), !!sym(year_col), target, name = "n") %>%
  complete(!!sym(country_col), !!sym(year_col), target, fill = list(n = 0)) %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  mutate(total = sum(n), share = if_else(total > 0, n/total, NA_real_)) %>%
  ungroup() %>%
  rename(country = !!sym(country_col), year = !!sym(year_col)) %>%
  arrange(country, year) %>%
  group_by(country, target) %>%
  mutate(share_ma3 = ma3_trailing(share)) %>%
  ungroup()

# FÃ¼r den 2-Linien-Plot: Consumer UND Non-Consumer
cn_cy <- cn_base %>%
  mutate(dim = if_else(target == "Consumer", "Consumer share", "Non-Consumer share")) %>%
  select(country, year, dim, share, share_ma3)

# ---- 1b) Dist3 (Progressive/Targeting/Regressive) COUNTS -> Shares (unverÃ¤ndert) ----
dist3_counts <- {
  base_cons <- all_policies_std %>%
    mutate(dataset = case_when(
      tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
      tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
      TRUE ~ dataset
    )) %>%
    filter(.data[[year_col]] >= 1990, .data[[year_col]] <= 2022) %>%
    filter(target == "Consumer", dataset %in% c("Subsidy","Regulation")) %>%
    mutate(dist_raw = case_when(
      dataset == "Subsidy"    ~ as.character(income_group),
      dataset == "Regulation" ~ as.character(income_burden_group),
      TRUE ~ NA_character_
    )) %>%
    filter(!is.na(dist_raw), dist_raw != "Not applicable (non-consumer)") %>%
    mutate(dist3 = case_when(
      dataset == "Subsidy"    & dist_raw == "Higher income" ~ "Regressive",
      dataset == "Regulation" & dist_raw == "Lower income"  ~ "Regressive",
      dist_raw == "All incomes equally"                     ~ "Progressive",
      dataset == "Subsidy"    & dist_raw == "Lower income"  ~ "Targeting",
      dataset == "Regulation" & dist_raw == "Higher income" ~ "Targeting",
      TRUE ~ NA_character_
    )) %>%
    filter(!is.na(dist3))

  base_cons %>%
    count(!!sym(country_col), !!sym(year_col), dist3, name = "n") %>%
    complete(!!sym(country_col), !!sym(year_col), dist3, fill = list(n = 0)) %>%
    rename(country = !!sym(country_col), year = !!sym(year_col))
}

dist3_cy <- dist3_counts %>%
  group_by(country, year) %>%
  mutate(total = sum(n, na.rm = TRUE),
         share = if_else(total > 0, n/total, NA_real_)) %>%
  ungroup() %>%
  group_by(country, dist3) %>%
  arrange(year, .by_group = TRUE) %>%
  mutate(share_ma3 = ma3_trailing(share)) %>%
  ungroup()

# ---- 2) Jahresmittel + SE (unverÃ¤ndert) ----
summarise_year <- function(df, value_col) {
  df %>%
    group_by(year) %>%
    summarise(
      mean_share = mean(.data[[value_col]], na.rm = TRUE),
      se_share   = sd(.data[[value_col]], na.rm = TRUE) /
                   sqrt(sum(is.finite(.data[[value_col]]))),
      n_countries = sum(is.finite(.data[[value_col]])),
      .groups = "drop"
    ) %>%
    left_join(active_by_year, by = "year") %>%
    mutate(sufficient = n_active >= MIN_ACTIVE)
}

# FÃ¼r SR jetzt 2 Komponenten (Regulation + Fiscal Support)
sr_year <- sr_cy %>%
  group_by(dim) %>%
  group_modify(~ summarise_year(.x, "share_ma3")) %>%
  ungroup()

# FÃ¼r CN jetzt 2 Komponenten (Consumer + Non-Consumer)
cn_year <- cn_cy %>%
  group_by(dim) %>%
  group_modify(~ summarise_year(.x, "share_ma3")) %>%
  ungroup()

# Dist3 (unverÃ¤ndert)
d3_year <- dist3_cy %>%
  group_by(year, dist3) %>%
  summarise(
    mean_share = mean(share_ma3, na.rm = TRUE),
    se_share   = sd(share_ma3,   na.rm = TRUE) /
                 sqrt(sum(is.finite(share_ma3))),
    n_countries = sum(is.finite(share_ma3)),
    .groups = "drop"
  ) %>%
  left_join(active_by_year, by = "year") %>%
  mutate(sufficient = n_active >= MIN_ACTIVE) %>%
  rename(dim = dist3)

# ---- 3) Mixed-Effects Helper (unverÃ¤ndert) ----
fe_line_from_RI <- function(df_cy, value_col, color = "black",
                            linetype = "solid", size = 0.7) {
  df <- df_cy %>%
    rename(country = !!sym("country"), year = !!sym("year"), y = !!sym(value_col)) %>%
    filter(is.finite(y)) %>%
    mutate(year_c = year - mean(year, na.rm = TRUE))

  m <- lmer(y ~ year_c + (1|country), data = df)
  co <- summary(m)$coefficients
  b0 <- as.numeric(co["(Intercept)","Estimate"])
  b1 <- as.numeric(co["year_c","Estimate"])
  p  <- as.numeric(co["year_c","Pr(>|t|)"])

  yr_seq <- sort(unique(df$year))
  yr_c   <- yr_seq - mean(df$year, na.rm = TRUE)
  pred   <- b0 + b1 * yr_c

  list(
    line_df = tibble::tibble(year = yr_seq, fe_pred = pred),
    beta = b1, p = p,
    aes_params = list(color = color, linetype = linetype, linewidth = size)
  )
}

robust_flag <- function(df_cy, value_col, beta_full,
                        y_min = ROBUST_MIN_YEAR, y_max = ROBUST_MAX_YEAR,
                        alpha = ALPHA) {
  df_sub <- df_cy %>%
    rename(country = !!sym("country"), year = !!sym("year"), y = !!sym(value_col)) %>%
    filter(is.finite(y), year >= y_min)

  if (!is.null(y_max) && is.finite(y_max)) {
    df_sub <- df_sub %>% filter(year <= y_max)
  }
  if (nrow(df_sub) == 0 || dplyr::n_distinct(df_sub$year) < 5) return(FALSE)

  df_sub <- df_sub %>% mutate(year_c = year - mean(year, na.rm = TRUE))
  m_sub <- try(lmer(y ~ year_c + (1|country), data = df_sub), silent = TRUE)
  if (inherits(m_sub, "try-error")) return(FALSE)

  co <- summary(m_sub)$coefficients
  beta_sub <- as.numeric(co["year_c","Estimate"])
  p_sub    <- as.numeric(co["year_c","Pr(>|t|)"])
  isTRUE((beta_full * beta_sub) > 1e-12 & p_sub < alpha)
}

# ---- Helper: robust note (fix) ----
robust_note_once <- function(flags, label = "1999â€“2019") {
  f <- if (is.list(flags)) {
    vapply(flags, isTRUE, logical(1))
  } else if (is.logical(flags)) {
    flags & !is.na(flags)
  } else {
    as.logical(flags)
  }
  if (length(f) == 0) return(paste0(" â€¢ Robust ", label, ": â€“"))
  if (all(f)) paste0(" â€¢ Robust ", label, ": âœ“") else paste0(" â€¢ Robust ", label, ": â€“")
}

# ---- Einheitliche Subtitle-Helfer ----
unit_tag <- " [pp/year]"
mk_subtitle_2 <- function(lab1, b1, p1, lab2, b2, p2, note = "") {
  sprintf("Random Intercept Time Slopes: %s Î²=%.3f (p=%.3g); %s Î²=%.3f (p=%.3g)%s%s",
          lab1, b1, p1, lab2, b2, p2, unit_tag, note)
}
mk_subtitle_3 <- function(lab1, b1, p1, lab2, b2, p2, lab3, b3, p3, note = "") {
  sprintf("Random Intercept Time Slopes: %s Î²=%.3f (p=%.3g); %s Î²=%.3f (p=%.3g); %s Î²=%.3f (p=%.3g)%s%s",
          lab1, b1, p1, lab2, b2, p2, lab3, b3, p3, unit_tag, note)
}

# ---- Farben (laut Vorgabe) ----
col_fs <- "#4C9BE8" # Fiscal Support
col_sr <- "#C0392B" # Regulation
col_cn <- "#4C9BE8" # Consumer
col_nc <- "#1E6BB8" # Non-Consumer
pal_d3 <- c("Progressive"="#4C9BE8","Targeting"="#F5A623","Regressive"="#C0392B")
pal_d2 <- c("Progressive"="#2E86C1", "Regressive"="#C0392B")

# ---- FE-Linien (SR/CN je Komponente) ----
fe_sr_reg <- fe_line_from_RI(sr_cy %>% filter(dim=="Regulation share")      %>% select(country, year, share),
                             value_col = "share", color = col_sr)
fe_sr_fis <- fe_line_from_RI(sr_cy %>% filter(dim=="Fiscal Support share")  %>% select(country, year, share),
                             value_col = "share", color = col_fs)

fe_cn_cons <- fe_line_from_RI(cn_cy %>% filter(dim=="Consumer share")       %>% select(country, year, share),
                              value_col = "share", color = col_cn)
fe_cn_non  <- fe_line_from_RI(cn_cy %>% filter(dim=="Non-Consumer share")   %>% select(country, year, share),
                              value_col = "share", color = col_nc)

# ---- Robust 1999â€“2019 (SR/CN) ----
flag_sr_reg <- robust_flag(sr_cy %>% filter(dim=="Regulation share"),     "share", fe_sr_reg$beta, y_min = 1999, y_max = 2019)
flag_sr_fis <- robust_flag(sr_cy %>% filter(dim=="Fiscal Support share"), "share", fe_sr_fis$beta, y_min = 1999, y_max = 2019)
flag_cn_con <- robust_flag(cn_cy %>% filter(dim=="Consumer share"),       "share", fe_cn_cons$beta, y_min = 1999, y_max = 2019)
flag_cn_non <- robust_flag(cn_cy %>% filter(dim=="Non-Consumer share"),   "share", fe_cn_non$beta,  y_min = 1999, y_max = 2019)

# --- Ausgabe & Export des CN-"Regulation Exclusion"-Tests -------------------
# === NEU: CN â€žRegulation Exclusionâ€œ (nur Fiscal Support) ===
cn_base_fs <- all_policies_std %>%
  mutate(
    dataset = case_when(
      tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
      tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
      TRUE ~ dataset
    ),
    target = if_else(target == "Structural", "Non-Consumer", target)
  ) %>%
  filter(.data[[year_col]] >= 1990, .data[[year_col]] <= 2022) %>%
  filter(dataset == "Subsidy", target %in% c("Consumer","Non-Consumer")) %>%
  count(!!sym(country_col), !!sym(year_col), target, name = "n") %>%
  complete(!!sym(country_col), !!sym(year_col), target, fill = list(n = 0)) %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  mutate(total = sum(n), share = if_else(total > 0, n/total, NA_real_)) %>%
  ungroup() %>%
  rename(country = !!sym(country_col), year = !!sym(year_col)) %>%
  arrange(country, year) %>%
  group_by(country, target) %>%
  mutate(share_ma3 = ma3_trailing(share)) %>%
  ungroup()

cn_cy_fs <- cn_base_fs %>%
  mutate(dim = if_else(target == "Consumer", "Consumer share", "Non-Consumer share")) %>%
  select(country, year, dim, share, share_ma3)

fe_cn_cons_fs <- fe_line_from_RI(
  cn_cy_fs %>% filter(dim == "Consumer share") %>% select(country, year, share),
  value_col = "share", color = col_cn
)
fe_cn_non_fs <- fe_line_from_RI(
  cn_cy_fs %>% filter(dim == "Non-Consumer share") %>% select(country, year, share),
  value_col = "share", color = col_nc
)

flag_cn_con_fs <- robust_flag(
  cn_cy_fs %>% filter(dim=="Consumer share"), "share", fe_cn_cons_fs$beta, y_min = 1999, y_max = 2019
)
flag_cn_non_fs <- robust_flag(
  cn_cy_fs %>% filter(dim=="Non-Consumer share"), "share", fe_cn_non_fs$beta, y_min = 1999, y_max = 2019
)

# --- Ausgabe & Export des CN-"Regulation Exclusion"-Tests -------------------
# Kompakte Konsolen-Diagnose (JETZT sind die Objekte definiert)
print(list(
  CN_Regulation_Exclusion = list(
    Consumer_FS    = list(beta_full = fe_cn_cons_fs$beta, p_full = fe_cn_cons_fs$p, flag = flag_cn_con_fs),
    NonConsumer_FS = list(beta_full = fe_cn_non_fs$beta,  p_full = fe_cn_non_fs$p,  flag = flag_cn_non_fs)
  )
))

# Tabellarisch + CSV
cn_rex_tbl <- tibble::tibble(
  dimension        = c("Consumer (FS only)", "Non-Consumer (FS only)"),
  beta_full        = c(fe_cn_cons_fs$beta,    fe_cn_non_fs$beta),
  p_full           = c(fe_cn_cons_fs$p,       fe_cn_non_fs$p),
  robust_1999_2019 = c(flag_cn_con_fs,        flag_cn_non_fs)
)
readr::write_csv(cn_rex_tbl, "robustness_CN_regulation_exclusion.csv")

# Einheits-Untertitel (mit gemeinsamer Robust-Notiz pro Figur)
note_sr_cn <- robust_note_once(c(flag_sr_reg, flag_sr_fis), "1999â€“2019")
note_cn    <- robust_note_once(c(flag_cn_con, flag_cn_non), "1999â€“2019")

# === NEU: CN â€žRegulation Exclusionâ€œ (nur Fiscal Support) ===
cn_base_fs <- all_policies_std %>%
  mutate(
    dataset = case_when(
      tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
      tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
      TRUE ~ dataset
    ),
    target = if_else(target == "Structural", "Non-Consumer", target)
  ) %>%
  filter(.data[[year_col]] >= 1990, .data[[year_col]] <= 2022) %>%
  filter(dataset == "Subsidy", target %in% c("Consumer","Non-Consumer")) %>%
  count(!!sym(country_col), !!sym(year_col), target, name = "n") %>%
  complete(!!sym(country_col), !!sym(year_col), target, fill = list(n = 0)) %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  mutate(total = sum(n), share = if_else(total > 0, n/total, NA_real_)) %>%
  ungroup() %>%
  rename(country = !!sym(country_col), year = !!sym(year_col)) %>%
  arrange(country, year) %>%
  group_by(country, target) %>%
  mutate(share_ma3 = ma3_trailing(share)) %>%
  ungroup()

cn_cy_fs <- cn_base_fs %>%
  mutate(dim = if_else(target == "Consumer", "Consumer share", "Non-Consumer share")) %>%
  select(country, year, dim, share, share_ma3)

fe_cn_cons_fs <- fe_line_from_RI(cn_cy_fs %>% filter(dim=="Consumer share")     %>% select(country, year, share),
                                 value_col = "share", color = col_cn)
fe_cn_non_fs  <- fe_line_from_RI(cn_cy_fs %>% filter(dim=="Non-Consumer share") %>% select(country, year, share),
                                 value_col = "share", color = col_nc)

flag_cn_con_fs <- robust_flag(cn_cy_fs %>% filter(dim=="Consumer share"),     "share", fe_cn_cons_fs$beta, y_min = 1999, y_max = 2019)
flag_cn_non_fs <- robust_flag(cn_cy_fs %>% filter(dim=="Non-Consumer share"), "share", fe_cn_non_fs$beta,  y_min = 1999, y_max = 2019)

note_cn_fs <- robust_note_once(c(flag_cn_con_fs, flag_cn_non_fs), "Regulation Exclusion")

# Untertitel zusammenbauen (Standard-Robustheit + Exclusion-Check)
sub_sr2 <- mk_subtitle_2(
  "Regulation",     fe_sr_reg$beta, fe_sr_reg$p,
  "Fiscal Support", fe_sr_fis$beta, fe_sr_fis$p,
  note = note_sr_cn
)
sub_cn2 <- mk_subtitle_2(
  "Consumer",       fe_cn_cons$beta, fe_cn_cons$p,
  "Non-Consumer",   fe_cn_non$beta,  fe_cn_non$p,
  note = paste0(note_cn, " ", note_cn_fs)
)

# ---- PLOTS A: SR (2 Linien) & CN (2 Linien) --------------------------------
p_sr <- ggplot(sr_year, aes(year, mean_share, color = dim, fill = dim)) +
  geom_ribbon(aes(ymin = mean_share - se_share, ymax = mean_share + se_share),
              alpha = 0.12, color = NA) +
  geom_line(linewidth = 0.7) +
  geom_point(aes(alpha = sufficient)) +
  geom_line(data = fe_sr_reg$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = col_sr, linewidth = 0.8) +
  geom_line(data = fe_sr_fis$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = col_fs, linewidth = 0.8) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.35), guide = "none") +
  scale_color_manual(values = c("Regulation share" = col_sr,
                                "Fiscal Support share" = col_fs),
                     name = NULL) +
  scale_fill_manual(values  = c("Regulation share" = col_sr,
                                "Fiscal Support share" = col_fs),
                    name = NULL) +
  scale_y_continuous(labels = percent) +
  labs(title = "Fiscal Support Ã— Regulations â€” mean across countries (SE band)",
       subtitle = sub_sr2, x = NULL, y = "Share") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "top", plot.subtitle = element_text(size = 8))

p_cn <- ggplot(cn_year, aes(year, mean_share, color = dim, fill = dim)) +
  geom_ribbon(aes(ymin = mean_share - se_share, ymax = mean_share + se_share),
              alpha = 0.12, color = NA) +
  geom_line(linewidth = 0.7) +
  geom_point(aes(alpha = sufficient)) +
  geom_line(data = fe_cn_cons$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = col_cn, linewidth = 0.8) +
  geom_line(data = fe_cn_non$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = col_nc, linewidth = 0.8) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.35), guide = "none") +
  scale_color_manual(values = c("Consumer share" = col_cn,
                                "Non-Consumer share" = col_nc),
                     name = NULL) +
  scale_fill_manual(values  = c("Consumer share" = col_cn,
                                "Non-Consumer share" = col_nc),
                    name = NULL) +
  scale_y_continuous(labels = percent) +
  labs(title = "Consumer vs Non-Consumer â€” mean across countries (SE band)",
       subtitle = sub_cn2, x = NULL, y = "Share") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "top", plot.subtitle = element_text(size = 6.5))

# ---- 5) Dist3 mit FE (unverÃ¤ndert inhaltlich) ------------------------------
fe_prog <- fe_line_from_RI(
  dist3_cy %>% filter(dist3=="Progressive") %>% select(country, year, share),
  value_col = "share", color = pal_d3["Progressive"]
)
fe_targ <- fe_line_from_RI(
  dist3_cy %>% filter(dist3=="Targeting") %>% select(country, year, share),
  value_col = "share", color = pal_d3["Targeting"]
)
fe_regr <- fe_line_from_RI(
  dist3_cy %>% filter(dist3=="Regressive") %>% select(country, year, share),
  value_col = "share", color = pal_d3["Regressive"]
)

flags_d3 <- c(
  robust_flag(dist3_cy %>% filter(dist3=="Progressive"), "share", fe_prog$beta,
              y_min = 1999, y_max = 2019),
  robust_flag(dist3_cy %>% filter(dist3=="Targeting"),  "share", fe_targ$beta,
              y_min = 1999, y_max = 2019),
  robust_flag(dist3_cy %>% filter(dist3=="Regressive"), "share", fe_regr$beta,
              y_min = 1999, y_max = 2019)
)
note_d3 <- robust_note_once(flags_d3, "1999â€“2019")

subtitle_d3 <- mk_subtitle_3(
  "Progressive", fe_prog$beta, fe_prog$p,
  "Targeting",   fe_targ$beta, fe_targ$p,
  "Regressive",  fe_regr$beta, fe_regr$p,
  note = note_d3
)

# ---- 6) Dist2 (unverÃ¤ndert, nur Reihenfolge spÃ¤ter getauscht) -------------
dist2_cy <- dist3_counts %>%
  mutate(dist2 = ifelse(dist3 %in% c("Progressive","Targeting"),
                        "Progressive", "Regressive")) %>%
  group_by(country, year, dist2) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop") %>%
  group_by(country, year) %>%
  mutate(total = sum(n, na.rm = TRUE),
         share = if_else(total > 0, n/total, NA_real_)) %>%
  ungroup() %>%
  group_by(country, dist2) %>%
  arrange(year, .by_group = TRUE) %>%
  mutate(share_ma3 = ma3_trailing(share)) %>%
  ungroup()

d2_year <- dist2_cy %>%
  group_by(dist2) %>%
  group_modify(~ summarise_year(.x, "share_ma3")) %>%
  ungroup() %>%
  rename(dim = dist2)

fe_d2_prog <- fe_line_from_RI(
  dist2_cy %>% filter(dist2=="Progressive") %>% select(country, year, share),
  value_col = "share", color = pal_d2["Progressive"]
)
fe_d2_regr <- fe_line_from_RI(
  dist2_cy %>% filter(dist2=="Regressive") %>% select(country, year, share),
  value_col = "share", color = pal_d2["Regressive"]
)

flags_d2 <- c(
  robust_flag(dist2_cy %>% filter(dist2=="Progressive"), "share", fe_d2_prog$beta, y_min=1999, y_max=2019),
  robust_flag(dist2_cy %>% filter(dist2=="Regressive"),             "share", fe_d2_regr$beta, y_min=1999, y_max=2019)
)
note_d2 <- robust_note_once(flags_d2, "1999â€“2019")

subtitle_d2 <- mk_subtitle_2(
  "Prog+Target", fe_d2_prog$beta, fe_d2_prog$p,
  "Regressive",  fe_d2_regr$beta, fe_d2_regr$p,
  note = note_d2
)

# ---- Debug-Check: Flags & Notes (nach Berechnung!) ----
print(list(flags_d2 = flags_d2, note_d2 = note_d2))
print(list(flags_d3 = flags_d3, note_d3 = note_d3))

# ---- PLOTS: Dist3 / Dist2 ----
p_d3 <- ggplot(d3_year, aes(year, mean_share, color = dim, fill = dim)) +
  geom_ribbon(aes(ymin = mean_share - se_share, ymax = mean_share + se_share),
              alpha = 0.12, color = NA) +
  geom_line() +
  geom_point(aes(alpha = sufficient)) +
  geom_line(data = fe_prog$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = pal_d3["Progressive"], linewidth = 0.6) +
  geom_line(data = fe_targ$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = pal_d3["Targeting"], linewidth = 0.6) +
  geom_line(data = fe_regr$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = pal_d3["Regressive"], linewidth = 0.6) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.35), guide = "none") +
  scale_color_manual(values = pal_d3, name = NULL) +
  scale_fill_manual(values  = pal_d3, name = NULL) +
  scale_y_continuous(labels = percent) +
  labs(title = "Progressive / Targeting / Regressive â€” mean across countries (SE band)",
       subtitle = subtitle_d3, x = NULL, y = "Share") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "top",  plot.subtitle = element_text(size = 6) )

p_d2 <- ggplot(d2_year, aes(year, mean_share, color = dim, fill = dim)) +
  geom_ribbon(aes(ymin = mean_share - se_share, ymax = mean_share + se_share),
              alpha = 0.12, color = NA) +
  geom_line() +
  geom_point(aes(alpha = sufficient)) +
  geom_line(data = fe_d2_prog$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = pal_d2["Progressive"], linewidth = 0.6) +
  geom_line(data = fe_d2_regr$line_df, aes(x = year, y = fe_pred),
            inherit.aes = FALSE, color = pal_d2["Regressive"], linewidth = 0.6) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.35), guide = "none") +
  scale_color_manual(values = pal_d2, name = NULL) +
  scale_fill_manual(values  = pal_d2, name = NULL) +
  scale_y_continuous(labels = percent) +
  labs(title = "Progressive vs Regressive â€” mean across countries (SE band)",
       subtitle = subtitle_d2, x = NULL, y = "Share") +
  theme_minimal(base_size = 11) +
  theme(legend.position = "top", plot.subtitle = element_text(size = 7))

# ---- 7) ZWEI GETRENNTE AUSGABEN -------------------------------------------
# Grafik A: SR (2 Linien) / CN (2 Linien)
p_figA <- (p_sr / p_cn)
print(p_figA)

ggsave("overview_trends_SR_CN_A4.pdf", p_figA,
       width = A4W, height = A4H, units = "in", device = cairo_pdf)
ggsave("overview_trends_SR_CN_A4.png", p_figA,
       width = A4W, height = A4H, units = "in", dpi = 300)

# Grafik B: Dist2 (oben) / Dist3 (unten)
p_figB <- (p_d2 / p_d3)
print(p_figB)

ggsave("overview_trends_Dist2_Dist3_A4.pdf", p_figB,
       width = A4W, height = A4H, units = "in", device = cairo_pdf)
ggsave("overview_trends_Dist2_Dist3_A4.png", p_figB,
       width = A4W, height = A4H, units = "in", dpi = 300)

# ZusÃ¤tzlich: Dist2- und Dist3-Plot separat speichern
ggsave("trend_Dist2_A4.pdf", p_d2,
       width = A4W, height = A4H/2, units = "in", device = cairo_pdf)
ggsave("trend_Dist2_A4.png", p_d2,
       width = A4W, height = A4H/2, units = "in", dpi = 300)

ggsave("trend_Dist3_A4.pdf", p_d3,
       width = A4W, height = A4H/2, units = "in", device = cairo_pdf)
ggsave("trend_Dist3_A4.png", p_d3,
       width = A4W, height = A4H/2, units = "in", dpi = 300)

# ---- 8/9) Mixed-Effects-Tabellen/Exports (unverÃ¤ndert) --------------------
if (!exists("me_results")) me_results <- list()

if (!exists("fit_me_tests")) {
  center_year <- function(y) y - mean(y, na.rm = TRUE)
  fit_me_tests <- function(df_cy, value_col, label) {
    df <- df_cy %>%
      rename(country = !!sym("country"), year = !!sym("year"), share = !!sym(value_col)) %>%
      filter(is.finite(share)) %>%
      mutate(year_c = center_year(year))
    res <- list(label = label)
    m_ri <- try(lmer(share ~ year_c + (1|country), data = df), silent = TRUE)
    if (!inherits(m_ri, "try-error")) {
      s <- summary(m_ri)
      res$RI <- c(beta = s$coefficients["year_c","Estimate"],
                  se   = s$coefficients["year_c","Std. Error"],
                  p    = s$coefficients["year_c","Pr(>|t|)"])
    }
    res
  }
}

me_results$D2_ProgPlus  <- fit_me_tests(
  df_cy = dist2_cy %>% filter(dist2=="Progressive") %>% select(country, year, share),
  value_col = "share", label = "Progressive+Targeting share"
)
me_results$D2_Regressive <- fit_me_tests(
  df_cy = dist2_cy %>% filter(dist2=="Regressive") %>% select(country, year, share),
  value_col = "share", label = "Regressive share"
)

if (exists("me_long")) {
  me_long2 <- bind_rows(
    me_long,
    bind_rows(lapply(c("D2_ProgPlus","D2_Regressive"), function(nm) {
      x <- me_results[[nm]]
      to_df <- function(part) {
        if (is.null(x[[part]])) return(NULL)
        tibble::tibble(
          dimension = nm, model = part,
          beta = as.numeric(x[[part]]["beta"]),
          se   = as.numeric(x[[part]]["se"]),
          p    = as.numeric(x[[part]]["p"]),
          AIC  = NA_real_
        )
      }
      bind_rows(to_df("RI"))
    }))
  )
} else {
  me_long2 <- bind_rows(lapply(c("D2_ProgPlus","D2_Regressive"), function(nm) {
    x <- me_results[[nm]]
    tibble::tibble(
      dimension = nm, model = "RI",
      beta = as.numeric(x$RI["beta"]),
      se   = as.numeric(x$RI["se"]),
      p    = as.numeric(x$RI["p"]),
      AIC  = NA_real_
    )
  }))
}

readr::write_csv(me_long2, "mixed_effects_trend_tests_WITH_D2.csv")

library(kableExtra)

dim_order <- c(
  "SR_Regulation","CN_Consumer",
  "D3_Progressive","D3_Targeting","D3_Regressive",
  "D2_ProgPlus","D2_Regressive"
)
dim_labels <- c(
  SR_Regulation  = "Regulation share",
  CN_Consumer    = "Consumer share",
  D3_Progressive = "Progressive (Dist3)",
  D3_Targeting   = "Targeting (Dist3)",
  D3_Regressive  = "Regressive (Dist3)",
  D2_ProgPlus    = "Progressive+Targeting (Dist2)",
  D2_Regressive  = "Regressive (Dist2)"
)

me_summary_RI <- me_long2 %>%
  filter(model == "RI") %>%
  mutate(
    dimension = factor(dimension, levels = dim_order),
    label = dim_labels[as.character(dimension)],
    beta_ppy = 100 * beta,
    se_ppy   = 100 * se,
    ci_low   = beta_ppy - 1.96 * se_ppy,
    ci_high  = beta_ppy + 1.96 * se_ppy,
    sig_5    = p < 0.05,
    arrow    = case_when(beta_ppy > 0 ~ "\u2191", beta_ppy < 0 ~ "\u2193", TRUE ~ "\u2192"),
    badge    = ifelse(sig_5, "\\textbf{Yes}", "No")
  ) %>%
  arrange(dimension) %>%
  transmute(
    Dimension = label,
    `Î² (pp/yr)`     = sprintf("%+.2f", beta_ppy),
    `95%% CI`       = sprintf("[%+.2f, %+.2f]", ci_low, ci_high),
    `p-value`       = ifelse(p < 0.0001, format(p, digits = 2, scientific = TRUE),
                             sprintf("%.4f", p)),
    AIC             = ifelse(is.finite(AIC), sprintf("%.1f", AIC), "â€“"),
    Direction       = arrow,
    `Significant (5\\%%)` = badge
  )

write_csv(me_summary_RI, "mixed_effects_summary_RI.csv")

library(kableExtra)
nc <- ncol(me_summary_RI)
tex_RI <- me_summary_RI |>
  kbl(format="latex", booktabs=TRUE, longtable=TRUE,
      escape=FALSE, linesep="",
      caption="Mixed-effects trend tests (Random Intercept). Effect sizes in percentage points per year.",
      label="tab:mixed-effects-summary-RI",
      align=c("l", rep("r", nc - 1))) |>
  kable_styling(latex_options=c("hold_position","repeat_header","striped"),
                stripe_color="gray!10", full_width=FALSE, font_size=9)
writeLines(tex_RI, "mixed_effects_summary_RI.tex")

if (any(me_long2$model != "RI")) {
  me_summary_all <- me_long2 %>%
    mutate(
      dimension = factor(dimension, levels = dim_order),
      label = dim_labels[as.character(dimension)],
      beta_ppy = 100 * beta, se_ppy = 100 * se,
      ci_low   = beta_ppy - 1.96 * se_ppy,
      ci_high  = beta_ppy + 1.96 * se_ppy,
      sig_5    = p < 0.05
    ) %>%
    arrange(dimension, match(model, c("RI","RS","AR1"))) %>%
    transmute(
      Dimension = label, Model = model,
      `Î² (pp/yr)` = sprintf("%+.2f", beta_ppy),
      `95%% CI`   = sprintf("[%+.2f, %+.2f]", ci_low, ci_high),
      `p-value`   = ifelse(p < 0.0001, format(p, digits = 2, scientific = TRUE),
                           sprintf("%.4f", p)),
      AIC         = ifelse(is.finite(AIC), sprintf("%.1f", AIC), "â€“"),
      `Sig (5\\%%)` = ifelse(sig_5, "\\textbf{Yes}", "No")
    )
  write_csv(me_summary_all, "mixed_effects_summary_ALL.csv")

  tex_ALL <- me_summary_all %>%
    kbl(format="latex", booktabs=TRUE, longtable=TRUE,
        escape=FALSE, linesep="",
        caption="Mixed-effects trend tests across model specifications (RI, RS, AR(1)). Effect sizes in percentage points per year.",
        label="tab:mixed-effects-summary-ALL",
        align=c("l","c","r","r","r","r","c")) %>%
    kable_styling(latex_options=c("hold_position","repeat_header","scale_down","striped"),
                  stripe_color="gray!10", full_width=FALSE, font_size=9) %>%
    column_spec(1, width="4.2cm") %>%
    column_spec(2, width="1.2cm") %>%
    column_spec(3:6, width="2.1cm") %>%
    column_spec(7, width="1.6cm")
  writeLines(tex_ALL, "mixed_effects_summary_ALL.tex")
}

# 1) Dist2 country-year shares
readr::write_csv(
  dist2_cy %>% select(country, year, dist2, share, share_ma3),
  "dist2_countryyear_shares.csv"
)

# 2) Active-country coverage
readr::write_csv(
  active_by_year, 
  "active_countries_by_year.csv"
)

# FE (RI) auf share, einmal "full window" und 1999â€“2019
diag_d2 <- function(df) {
  library(lme4); library(lmerTest)
  df_ok <- df %>% filter(is.finite(share)) %>% mutate(year_c = year - mean(year, na.rm=TRUE))
  m <- lmer(share ~ year_c + (1|country), data = df_ok)
  s <- summary(m)$coefficients["year_c", c("Estimate","Std. Error","Pr(>|t|)")]
  as.numeric(s)
}

full_pp  <- diag_d2(dist2_cy %>% filter(dist2=="Progressive"))
full_reg <- diag_d2(dist2_cy %>% filter(dist2=="Regressive"))
w_pp     <- diag_d2(dist2_cy %>% filter(dist2=="Progressive", year>=1999, year<=2019))
w_reg    <- diag_d2(dist2_cy %>% filter(dist2=="Regressive",            year>=1999, year<=2019))

print(list(full_pp=full_pp, full_reg=full_reg, window_pp=w_pp, window_reg=w_reg))

cat("\nSaved: overview_trends_SR_CN_A4.(pdf|png)\n")
cat("Saved: overview_trends_Dist2_Dist3_A4.(pdf|png)\n")
cat("Saved: trend_Dist2_A4.(pdf|png)\n")
cat("Saved: trend_Dist3_A4.(pdf|png)\n")
cat("Saved: mixed_effects_trend_tests_WITH_D2.csv\n")
cat("Saved: mixed_effects_summary_RI.(csv|tex)\n")
cat("Saved: mixed_effects_summary_ALL.(csv|tex) [falls RS/AR1 vorhanden]\n")
cat("Saved: robustness_CN_regulation_exclusion.csv\n")
```

### 1.1.  Ausgabe substanzielle Interpretation 
```{r}
# ===== Substantive Interpretation (kompakt) =====
pp  <- function(x) sprintf("%.1f pp", 100*x)
pct <- function(x) sprintf("%.0f%%", 100*x)

# Robust: gibt NA zurÃ¼ck, wenn 1999/2019 fehlen (statt Fehler)
start_end_delta <- function(df_year, label, y0 = 1999, y1 = 2019) {
  s <- df_year %>% dplyr::filter(year == y0) %>% dplyr::pull(mean_share)
  e <- df_year %>% dplyr::filter(year == y1) %>% dplyr::pull(mean_share)
  if (length(s) == 0) s <- NA_real_
  if (length(e) == 0) e <- NA_real_
  tibble::tibble(dim = label, start = s, end = e, delta = e - s)
}

# SR: Regulation & Fiscal Support
sr_1999 <- sr_year %>% dplyr::filter(year == 1999) %>%
  dplyr::select(dim, mean_share) %>% tidyr::pivot_wider(names_from = dim, values_from = mean_share)
sr_2019 <- sr_year %>% dplyr::filter(year == 2019) %>%
  dplyr::select(dim, mean_share) %>% tidyr::pivot_wider(names_from = dim, values_from = mean_share)

sr_delta <- dplyr::bind_rows(
  start_end_delta(sr_year %>% dplyr::filter(dim == "Regulation share"),     "Regulation"),
  start_end_delta(sr_year %>% dplyr::filter(dim == "Fiscal Support share"), "Fiscal Support")
)

# CN: Consumer & Non-Consumer
cn_delta <- dplyr::bind_rows(
  start_end_delta(cn_year %>% dplyr::filter(dim == "Consumer share"),      "Consumer"),
  start_end_delta(cn_year %>% dplyr::filter(dim == "Non-Consumer share"),  "Non-Consumer")
)

# Dist2: ACHTUNG â€“ dim heisst "Progressive" ODER "Regressive" (nicht "Progressive+Targeting")
d2_delta <- dplyr::bind_rows(
  start_end_delta(d2_year %>% dplyr::filter(dim == "Progressive"), "Progressive"),
  start_end_delta(d2_year %>% dplyr::filter(dim == "Regressive"),  "Regressive")
)

# --- LaTeX-Satz-Generatoren ---
rob_str <- function(flag) if (isTRUE(flag)) "robust (1999â€“2019)" else "not robust (1999â€“2019)"
rex_str <- function(flag_pair) if (all(flag_pair)) "robust under regulation exclusion" else "not robust under regulation exclusion"

E1_line <- sprintf(
  "E1 (Fiscal Support > Regulation): Fiscal Support rises by Î²=%+.3f pp/year (p=%.3g), totaling %s from 1999 to 2019 (from %s to %s); trend is %s. Regulation falls by Î²=%+.3f pp/year (p=%.3g), totaling %s (from %s to %s); trend is %s.",
  100*fe_sr_fis$beta, fe_sr_fis$p, pp(sr_delta$delta[sr_delta$dim=="Fiscal Support"]),
  pp(sr_delta$start[sr_delta$dim=="Fiscal Support"]), pp(sr_delta$end[sr_delta$dim=="Fiscal Support"]), rob_str(flag_sr_fis),
  100*fe_sr_reg$beta, fe_sr_reg$p, pp(sr_delta$delta[sr_delta$dim=="Regulation"]),
  pp(sr_delta$start[sr_delta$dim=="Regulation"]), pp(sr_delta$end[sr_delta$dim=="Regulation"]), rob_str(flag_sr_reg)
)

E2_line <- sprintf(
  "E2 (Consumer â‰ˆ Non-Consumer): Consumer share increases by Î²=%+.3f pp/year (p=%.3g), totaling %s (from %s to %s); trend is %s and %s. Non-Consumer correspondingly declines by Î²=%+.3f pp/year (p=%.3g), totaling %s (from %s to %s); trend is %s and %s.",
  100*fe_cn_cons$beta, fe_cn_cons$p, pp(cn_delta$delta[cn_delta$dim=="Consumer"]),
  pp(cn_delta$start[cn_delta$dim=="Consumer"]), pp(cn_delta$end[cn_delta$dim=="Consumer"]), rob_str(flag_cn_con),
  rex_str(c(flag_cn_con_fs, flag_cn_non_fs)),
  100*fe_cn_non$beta,  fe_cn_non$p,  pp(cn_delta$delta[cn_delta$dim=="Non-Consumer"]),
  pp(cn_delta$start[cn_delta$dim=="Non-Consumer"]), pp(cn_delta$end[cn_delta$dim=="Non-Consumer"]), rob_str(flag_cn_non),
  rex_str(c(flag_cn_con_fs, flag_cn_non_fs))
)

E3_line <- sprintf(
  "E3 (Progressive > Regressive): Progressive rises by Î²=%+.3f pp/year (p=%.3g), totaling %s (from %s to %s); trend is %s. Regressive falls by Î²=%+.3f pp/year (p=%.3g), totaling %s (from %s to %s); trend is %s.",
  100*fe_d2_prog$beta, fe_d2_prog$p, pp(d2_delta$delta[d2_delta$dim=="Progressive"]),
  pp(d2_delta$start[d2_delta$dim=="Progressive"]), pp(d2_delta$end[d2_delta$dim=="Progressive"]), rob_str(flags_d2[1]),
  100*fe_d2_regr$beta, fe_d2_regr$p, pp(d2_delta$delta[d2_delta$dim=="Regressive"]),
  pp(d2_delta$start[d2_delta$dim=="Regressive"]), pp(d2_delta$end[d2_delta$dim=="Regressive"]), rob_str(flags_d2[2])
)

cat("\n--- Substantive summaries ---\n")
cat(E1_line, "\n")
cat(E2_line, "\n")
cat(E3_line, "\n")

# Optional: als CSV speichern
substantive_tbl <- tibble::tibble(
  expectation = c("E1_FiscalSupport","E1_Regulation","E2_Consumer","E2_NonConsumer","E3_Progressive","E3_Regressive"),
  beta_ppy = c(100*fe_sr_fis$beta, 100*fe_sr_reg$beta, 100*fe_cn_cons$beta, 100*fe_cn_non$beta, 100*fe_d2_prog$beta, 100*fe_d2_regr$beta),
  p_value  = c(fe_sr_fis$p, fe_sr_reg$p, fe_cn_cons$p, fe_cn_non$p, fe_d2_prog$p, fe_d2_regr$p),
  start_1999 = c(100*sr_delta$start[sr_delta$dim=="Fiscal Support"],
                 100*sr_delta$start[sr_delta$dim=="Regulation"],
                 100*cn_delta$start[cn_delta$dim=="Consumer"],
                 100*cn_delta$start[cn_delta$dim=="Non-Consumer"],
                 100*d2_delta$start[d2_delta$dim=="Progressive"],
                 100*d2_delta$start[d2_delta$dim=="Regressive"]),
  end_2019 = c(100*sr_delta$end[sr_delta$dim=="Fiscal Support"],
               100*sr_delta$end[sr_delta$dim=="Regulation"],
               100*cn_delta$end[cn_delta$dim=="Consumer"],
               100*cn_delta$end[cn_delta$dim=="Non-Consumer"],
               100*d2_delta$end[d2_delta$dim=="Progressive"],
               100*d2_delta$end[d2_delta$dim=="Regressive"]),
  delta_pp = c(100*sr_delta$delta[sr_delta$dim=="Fiscal Support"],
               100*sr_delta$delta[sr_delta$dim=="Regulation"],
               100*cn_delta$delta[cn_delta$dim=="Consumer"],
               100*cn_delta$delta[cn_delta$dim=="Non-Consumer"],
               100*d2_delta$delta[d2_delta$dim=="Progressive"],
               100*d2_delta$delta[d2_delta$dim=="Regressive"]),
  robust_1999_2019 = c(flag_sr_fis, flag_sr_reg, flag_cn_con, flag_cn_non, flags_d2[1], flags_d2[2]),
  cn_regulation_exclusion = c(NA, NA, all(c(flag_cn_con_fs, flag_cn_non_fs)), all(c(flag_cn_con_fs, flag_cn_non_fs)), NA, NA)
)
readr::write_csv(substantive_tbl, "substantive_interpretation_summary.csv")
```


## 2.3 Zeitliche VerlÃ¤ufe (within-country): Preparation (2 categories only)
```{r}
# ============================================================
# Within-country prep for distributive dimension (Progressive vs Regressive)
# ============================================================

library(dplyr)
library(tidyr)
library(rlang)

cons <- all_policies_std %>%
  filter(target == "Consumer") %>%
  ungroup()

cons <- cons %>%
  mutate(
    dist_raw = case_when(
      dataset == "Subsidy"    ~ as.character(income_group),
      dataset == "Regulation" ~ as.character(income_burden_group),
      TRUE ~ NA_character_
    ),
    dist_raw = trimws(dist_raw)
  ) %>%
  filter(!is.na(dist_raw), dist_raw != "Not applicable (non-consumer)")

cons_v1 <- cons %>%
  mutate(
    dist2 = case_when(
      dataset=="Subsidy"    & dist_raw=="Higher income"                              ~ "Regressive",
      dataset=="Subsidy"    & dist_raw %in% c("Lower income","All incomes equally")  ~ "Progressive",
      dataset=="Regulation" & dist_raw=="Lower income"                               ~ "Regressive",
      dataset=="Regulation" & dist_raw %in% c("All incomes equally","Higher income") ~ "Progressive",
      TRUE ~ NA_character_
    ),
    dist2   = factor(dist2, levels = c("Progressive","Regressive"), ordered = TRUE),
    segment = dist2
  ) %>%
  filter(!is.na(dist2)) %>%
  ungroup()

yearly_dist <- cons_v1 %>%
  count(!!sym(country_col), !!sym(year_col), segment, name = "n") %>%
  complete(!!sym(country_col), !!sym(year_col), segment, fill = list(n = 0)) %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  mutate(total = sum(n, na.rm = TRUE),
         share = ifelse(total > 0, n/total, NA_real_)) %>%
  ungroup() %>%
  mutate(segment = factor(segment, levels = levels(cons_v1$segment), ordered = TRUE))

yearly_dist <- yearly_dist %>%
  group_by(!!sym(country_col), segment) %>%
  arrange(!!sym(year_col), .by_group = TRUE) %>%
  mutate(
    share_ma3 = if (dplyr::n() >= 3) as.numeric(stats::filter(share, rep(1/3,3), sides = 2)) else NA_real_,
    share_use = dplyr::coalesce(share_ma3, share)
  ) %>%
  ungroup()

years_by_ctry <- cons_v1 %>%
  group_by(!!sym(country_col)) %>%
  summarise(ymin = min(.data[[year_col]], na.rm = TRUE),
            ymax = max(.data[[year_col]], na.rm = TRUE),
            .groups = "drop")

yearly_n_dist <- cons_v1 %>%
  count(!!sym(country_col), !!sym(year_col), segment, name = "n") %>%
  right_join(
    years_by_ctry %>%
      rowwise() %>%
      mutate(year_seq = list(seq.int(ymin, ymax))) %>%
      unnest(year_seq) %>%
      select(!!sym(country_col), !!sym(year_col) := year_seq) %>%
      tidyr::crossing(segment = factor(levels(cons_v1$segment),
                                       levels = levels(cons_v1$segment), ordered = TRUE)),
    by = c(country_col, year_col, "segment")
  ) %>%
  mutate(n = tidyr::replace_na(n, 0L)) %>%
  arrange(!!sym(country_col), !!sym(year_col), segment)

yearly_n_cum_dist <- yearly_n_dist %>%
  group_by(!!sym(country_col), segment) %>%
  arrange(!!sym(year_col), .by_group = TRUE) %>%
  mutate(cum_n = cumsum(n)) %>%
  ungroup()

window_min <- 1995; window_max <- 2020
order_countries_share <- yearly_dist %>%
  filter(.data[[year_col]] >= window_min, .data[[year_col]] <= window_max) %>%
  mutate(is_reg = segment == "Regressive") %>%
  group_by(!!sym(country_col), !!sym(year_col)) %>%
  summarise(reg_share = sum(ifelse(is_reg, share_use, 0), na.rm = TRUE), .groups = "drop") %>%
  group_by(!!sym(country_col)) %>%
  summarise(mean_reg_share = mean(reg_share, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(mean_reg_share)) %>%
  pull(!!sym(country_col))

order_countries_num <- yearly_n_dist %>%
  filter(segment == "Regressive") %>%
  group_by(!!sym(country_col)) %>%
  summarise(mean_reg_per_year = mean(n, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(mean_reg_per_year)) %>%
  pull(!!sym(country_col))

yearly_dist       <- yearly_dist       %>% mutate(!!sym(country_col) := factor(.data[[country_col]], levels = order_countries_share, ordered = TRUE))
yearly_n_cum_dist <- yearly_n_cum_dist %>% mutate(!!sym(country_col) := factor(.data[[country_col]], levels = order_countries_num,   ordered = TRUE))

# ============================================================
# Within-country SHARES (Progressive vs Regressive) â€” paginated A4
# ============================================================

library(ggplot2)
library(scales)
library(ggforce)
library(grid)

A4W <- 8.27; A4H <- 11.69
pal_2dist <- c("Progressive" = "#4C9BE8", "Regressive" = "#C0392B")

make_area_dist_share <- function(df, title, subtitle) {
  ggplot(df, aes(x = !!sym(year_col), y = share_use, fill = segment)) +
    geom_area(position = "fill", alpha = 0.9, na.rm = TRUE) +
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0,1)) +
    scale_fill_manual(values = pal_2dist, name = NULL) +
    labs(x = NULL, y = "Share (100%)", title = title, subtitle = subtitle,
         caption = "Within-country shares by distributive type (â‰¤ 2022); 3-year MA (fallback to raw).") +
    theme_minimal(base_size = 11) +
    theme(
      legend.position = "top",
      legend.key.size = unit(0.32,"cm"),
      legend.text = element_text(size = 8),
      plot.title = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5),
      strip.text = element_text(size = 8, lineheight = 0.95),
      panel.grid.minor = element_blank()
    )
}

p_dist_share <- make_area_dist_share(
  yearly_dist,
  title    = "Within-country distributive mix (shares)",
  subtitle = sprintf("Countries ordered by mean Regressive share (%dâ€“%d), descending.", window_min, window_max)
)

ncol_portrait <- 3; nrow_portrait <- 4
n_countries <- nlevels(yearly_dist[[country_col]])
pages <- ceiling(n_countries / (ncol_portrait * nrow_portrait))

pdf("within_country_distributive_SHARES_A4_portrait.pdf", width = A4W, height = A4H, useDingbats = FALSE)
for (i in seq_len(pages)) {
  print(
    p_dist_share +
      ggforce::facet_wrap_paginate(
        vars(!!sym(country_col)),
        ncol = ncol_portrait, nrow = nrow_portrait, page = i
      )
  )
}
dev.off()

# ============================================================
# Within-country NUMBERS (cumulative) â€” Progressive vs Regressive â€” paginated A4
# ============================================================

library(ggplot2)
library(ggforce)
library(grid)

A4W <- 8.27; A4H <- 11.69
pal_2dist <- c("Progressive" = "#4C9BE8", "Regressive" = "#C0392B")

make_area_dist_num <- function(df, title, subtitle) {
  ggplot(df, aes(x = !!sym(year_col), y = cum_n, fill = segment)) +
    geom_area(position = "stack", alpha = 0.95, na.rm = TRUE) +
    scale_fill_manual(values = pal_2dist, name = NULL) +
    labs(x = NULL, y = "Cumulative number of policies", title = title, subtitle = subtitle,
         caption = "Cumulative counts within country; missing years treated as zero.") +
    theme_minimal(base_size = 11) +
    theme(
      legend.position = "top",
      legend.key.size = unit(0.32,"cm"),
      legend.text = element_text(size = 8),
      plot.title = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5),
      strip.text = element_text(size = 8, lineheight = 0.95),
      panel.grid.minor = element_blank()
    )
}

p_dist_num <- make_area_dist_num(
  yearly_n_cum_dist,
  title    = "Within-country distributive mix (numbers, cumulative)",
  subtitle = "Countries ordered by average annual number of Regressive policies, descending."
)

ncol_portrait <- 3; nrow_portrait <- 4
n_countries_num <- nlevels(yearly_n_cum_dist[[country_col]])
pages_num <- ceiling(n_countries_num / (ncol_portrait * nrow_portrait))

pdf("within_country_distributive_NUMBERS_cumulative_A4_portrait.pdf", width = A4W, height = A4H, useDingbats = FALSE)
for (i in seq_len(pages_num)) {
  print(
    p_dist_num +
      ggforce::facet_wrap_paginate(
        vars(!!sym(country_col)),
        ncol = ncol_portrait, nrow = nrow_portrait, page = i
      )
  )
}
dev.off()

# ============================================================
# Tables (Consumer-only, Progressive vs Regressive by year-group)
# ============================================================

library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(kableExtra)
library(scales)
library(rlang)

year_breaks <- c(-Inf, 1999, 2009, 2015, 2022)
year_labels <- c("â‰¤1999","2000â€“2009","2010â€“2015","2016â€“2022")
stopifnot(length(year_breaks)-1 == length(year_labels))

cons <- all_policies_std %>%
  filter(target == "Consumer") %>%
  mutate(
    dist_raw = case_when(
      dataset == "Subsidy"    ~ as.character(income_group),
      dataset == "Regulation" ~ as.character(income_burden_group),
      TRUE ~ NA_character_
    ),
    dist_raw = trimws(dist_raw)
  ) %>%
  filter(!is.na(dist_raw), dist_raw != "Not applicable (non-consumer)")

cons_v1 <- cons %>%
  mutate(
    dist2 = case_when(
      dataset=="Subsidy"    & dist_raw=="Higher income"                              ~ "Regressive",
      dataset=="Subsidy"    & dist_raw %in% c("Lower income","All incomes equally")  ~ "Progressive",
      dataset=="Regulation" & dist_raw=="Lower income"                               ~ "Regressive",
      dataset=="Regulation" & dist_raw %in% c("All incomes equally","Higher income") ~ "Progressive",
      TRUE ~ NA_character_
    ),
    dist2 = factor(dist2, levels = c("Progressive","Regressive"), ordered = TRUE)
  ) %>%
  filter(!is.na(dist2))

countries_alpha <- cons_v1 %>%
  distinct(!!sym(country_col)) %>%
  transmute(cty = as.character(!!sym(country_col))) %>%
  arrange(cty) %>%
  pull(cty)

tab_dist_numeric <- cons_v1 %>%
  mutate(
    year_group = cut(.data[[year_col]], breaks = year_breaks, labels = year_labels,
                     right = TRUE, include.lowest = TRUE),
    !!sym(country_col) := factor(as.character(.data[[country_col]]),
                                 levels = countries_alpha, ordered = TRUE)
  ) %>%
  filter(!is.na(year_group)) %>%
  count(!!sym(country_col), year_group, dist2, name = "n") %>%
  group_by(!!sym(country_col), year_group) %>%
  mutate(total = sum(n), share = ifelse(total > 0, n/total, NA_real_)) %>%
  ungroup() %>%
  select(!!sym(country_col), year_group, dist2, share) %>%
  mutate(dist2 = factor(dist2, levels = c("Progressive","Regressive"))) %>%
  pivot_wider(names_from = c(year_group, dist2), values_from = share) %>%
  arrange(!!sym(country_col)) %>%
  rename(Country = !!sym(country_col)) %>%
  { yr <- year_labels
    wanted <- c()
    for (g in yr) wanted <- c(wanted, paste0(g,"_Progressive"), paste0(g,"_Regressive"))
    exist <- intersect(wanted, colnames(.))
    select(., Country, all_of(exist))
  }

write_csv(tab_dist_numeric, "appendix_table_dist2_consumer_by_yeargroup_NUMERIC.csv")

pct_fmt <- function(x, acc = 0.1) stringr::str_replace_all(scales::percent(x, accuracy = acc), "%","\\\\%")
tab_dist <- tab_dist_numeric
avg_row <- tab_dist %>%
  summarise(across(-Country, ~ if (all(is.na(.x))) NA_real_ else mean(.x, na.rm = TRUE)))
avg_row$Country <- "Average"
tab_dist_out <- bind_rows(tab_dist, avg_row) %>%
  mutate(across(-Country, ~ ifelse(is.finite(.x), pct_fmt(.x, 0.1), "â€“")))

write_csv(tab_dist_out, "appendix_table_dist2_consumer_by_yeargroup.csv")

lower_hdr <- c("Country", rep(c("Progressive","Regressive"), times = length(year_labels)))
upper_hdr <- {u <- c(" " = 1); for (g in year_labels) u[g] <- 2; u}

tab_dist_tex <- tab_dist_out %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE, linesep = "",
      caption = "Consumer policies â€” distributive shares by year-group (Progressive vs. Regressive).",
      label = "tab:dist2_consumer_by_yeargroup",
      align = c("l", rep("r", ncol(tab_dist_out)-1)),
      escape = FALSE, col.names = lower_hdr) %>%
  add_header_above(upper_hdr, escape = FALSE) %>%
  kable_styling(latex_options = c("hold_position","repeat_header","striped","scale_down"),
                stripe_color = "gray!12", full_width = FALSE, font_size = 8) %>%
  column_spec(1, width = "2.0cm") %>%
  column_spec(2:ncol(tab_dist_out), width = "1.35cm") %>%
  row_spec(nrow(tab_dist_out), bold = TRUE, background = "gray!08")

writeLines(tab_dist_tex, "appendix_table_dist2_consumer_by_yeargroup.tex")

# ============================================================
# TABLES (NUMBERS) â€” analog zu T1â€“T3, aber mit COUNTS
# - N1: All policies â€” counts by year-group (Fiscal Support vs Regulation)
# - N2: Consumer policies â€” counts by year-group (Fiscal Support vs Regulation)
# - N3: All policies â€” counts by year-group (Consumer vs Non-Consumer)
# CSVs + (optional) LaTeX
# ============================================================

# Helper: Summe- und Durchschnittszeile (fÃ¼r COUNTS)
add_total_and_avg_rows_counts <- function(wide_counts, country_name_col = "Country") {
  # Total (Summe Ã¼ber LÃ¤nder)
  tot <- wide_counts %>% dplyr::summarise(across(-all_of(country_name_col), ~ sum(.x, na.rm = TRUE)))
  tot[[country_name_col]] <- "Total"
  tot <- tot[, names(wide_counts)]
  # Average (Durchschnitt pro Land)
  avg <- wide_counts %>% dplyr::summarise(across(-all_of(country_name_col), ~ mean(.x, na.rm = TRUE)))
  avg[[country_name_col]] <- "Average (per country)"
  avg <- avg[, names(wide_counts)]
  dplyr::bind_rows(wide_counts, tot, avg)
}

# Gemeinsame Ordnung der LÃ¤nder beibehalten
countries_alpha <- all_policies_std %>%
  dplyr::filter(.data[[year_col]] <= 2022) %>%
  dplyr::distinct(!!sym(country_col)) %>%
  dplyr::transmute(country_chr = as.character(!!sym(country_col))) %>%
  dplyr::arrange(country_chr) %>%
  dplyr::pull(country_chr)

with_yeargroup_num <- all_policies_std %>%
  dplyr::filter(.data[[year_col]] <= 2022) %>%
  dplyr::mutate(
    year_group = cut(.data[[year_col]], breaks = year_breaks, labels = year_labels,
                     right = TRUE, include.lowest = TRUE),
    !!sym(country_col) := factor(as.character(.data[[country_col]]),
                                 levels = countries_alpha, ordered = TRUE),
    dataset = dplyr::case_when(
      tolower(dataset) %in% c("subsidy","subs","subsidies") ~ "Subsidy",
      tolower(dataset) %in% c("regulation","reg","regulations") ~ "Regulation",
      TRUE ~ dataset
    ),
    target = dplyr::case_when(
      target %in% c("Non-Consumer","Consumer") ~ target,
      target %in% c("Structural") ~ "Non-Consumer",
      TRUE ~ target
    )
  )

# ---------- N1: All policies â€” COUNTS by year-group (SR) ----------
tabN1_counts <- with_yeargroup_num %>%
  dplyr::filter(!is.na(year_group)) %>%
  dplyr::count(!!sym(country_col), year_group, dataset, name = "count") %>%
  dplyr::mutate(dataset = factor(dataset, levels = c("Subsidy","Regulation"))) %>%
  tidyr::pivot_wider(names_from = c(year_group, dataset), values_from = count, values_fill = 0) %>%
  dplyr::arrange(!!sym(country_col)) %>%
  dplyr::rename(Country = !!sym(country_col)) %>%
  { # Spalten pro Jahrgruppe: Subsidy dann Regulation
    yr <- year_labels
    wanted <- c()
    for (g in yr) wanted <- c(wanted, paste0(g, "_Subsidy"), paste0(g, "_Regulation"))
    exist <- intersect(wanted, colnames(.))
    dplyr::select(., Country, dplyr::all_of(exist))
  } %>%
  add_total_and_avg_rows_counts(country_name_col = "Country")

# CSV (sichtbare Spaltennamen mit â€žFiscalSupportâ€œ statt â€žSubsidyâ€œ)
names(tabN1_counts) <- sub("_Subsidy$", "_FiscalSupport", names(tabN1_counts))
readr::write_csv(tabN1_counts, "appendix_tableN1_COUNTS_SR_allpolicies_by_yeargroup.csv")

# OPTIONAL: LaTeX
tabN1_lower <- c("Country", rep(c("Fiscal Support","Regulation"), times = length(year_labels)))
tabN1_upper <- make_upper_spanner(year_labels)
tabN1_tex <- tabN1_counts %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE, linesep = "",
      caption = "N1: All policies â€” counts by year-group (Fiscal Support vs. Regulation).",
      label   = "tabN:SR_all_counts_by_yeargroup",
      align   = c("l", rep("r", ncol(tabN1_counts) - 1)),
      escape  = FALSE,
      col.names = tabN1_lower) %>%
  add_header_above(tabN1_upper, escape = FALSE) %>%
  kable_styling(latex_options = c("hold_position","repeat_header","striped","scale_down"),
                stripe_color  = "gray!12", full_width = FALSE, font_size = 8) %>%
  column_spec(1, width = "2.0cm") %>%
  column_spec(2:ncol(tabN1_counts), width = "1.35cm") %>%
  row_spec(nrow(tabN1_counts)-1, bold = TRUE) %>%   # "Total"
  row_spec(nrow(tabN1_counts), bold = TRUE, background = "gray!08")  # "Average"
writeLines(tabN1_tex, "appendix_tableN1_COUNTS_SR_allpolicies_by_yeargroup.tex")

# ---------- N2: Consumer policies â€” COUNTS by year-group (SR) ----------
tabN2_counts <- with_yeargroup_num %>%
  dplyr::filter(target == "Consumer", !is.na(year_group)) %>%
  dplyr::count(!!sym(country_col), year_group, dataset, name = "count") %>%
  dplyr::mutate(dataset = factor(dataset, levels = c("Subsidy","Regulation"))) %>%
  tidyr::pivot_wider(names_from = c(year_group, dataset), values_from = count, values_fill = 0) %>%
  dplyr::arrange(!!sym(country_col)) %>%
  dplyr::rename(Country = !!sym(country_col)) %>%
  {
    yr <- year_labels
    wanted <- c()
    for (g in yr) wanted <- c(wanted, paste0(g, "_Subsidy"), paste0(g, "_Regulation"))
    exist <- intersect(wanted, colnames(.))
    dplyr::select(., Country, dplyr::all_of(exist))
  } %>%
  add_total_and_avg_rows_counts(country_name_col = "Country")

names(tabN2_counts) <- sub("_Subsidy$", "_FiscalSupport", names(tabN2_counts))
readr::write_csv(tabN2_counts, "appendix_tableN2_COUNTS_SR_consumer_by_yeargroup.csv")

tabN2_lower <- c("Country", rep(c("Fiscal Support","Regulation"), times = length(year_labels)))
tabN2_upper <- make_upper_spanner(year_labels)
tabN2_tex <- tabN2_counts %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE, linesep = "",
      caption = "N2: Consumer policies â€” counts by year-group (Fiscal Support vs. Regulation).",
      label   = "tabN:SR_consumer_counts_by_yeargroup",
      align   = c("l", rep("r", ncol(tabN2_counts) - 1)),
      escape  = FALSE,
      col.names = tabN2_lower) %>%
  add_header_above(tabN2_upper, escape = FALSE) %>%
  kable_styling(latex_options = c("hold_position","repeat_header","striped","scale_down"),
                stripe_color  = "gray!12", full_width = FALSE, font_size = 8) %>%
  column_spec(1, width = "2.0cm") %>%
  column_spec(2:ncol(tabN2_counts), width = "1.35cm") %>%
  row_spec(nrow(tabN2_counts)-1, bold = TRUE) %>%
  row_spec(nrow(tabN2_counts), bold = TRUE, background = "gray!08")
writeLines(tabN2_tex, "appendix_tableN2_COUNTS_SR_consumer_by_yeargroup.tex")

# ---------- N3: All policies â€” COUNTS by year-group (Consumer vs Non-Consumer) ----------
tabN3_counts <- with_yeargroup_num %>%
  dplyr::filter(!is.na(year_group)) %>%
  dplyr::count(!!sym(country_col), year_group, target, name = "count") %>%
  dplyr::mutate(target = factor(target, levels = c("Consumer","Non-Consumer"))) %>%
  tidyr::pivot_wider(names_from = c(year_group, target), values_from = count, values_fill = 0) %>%
  dplyr::arrange(!!sym(country_col)) %>%
  dplyr::rename(Country = !!sym(country_col)) %>%
  {
    yr <- year_labels
    wanted <- c()
    for (g in yr) wanted <- c(wanted, paste0(g, "_Consumer"), paste0(g, "_Non-Consumer"))
    exist <- intersect(wanted, colnames(.))
    dplyr::select(., Country, dplyr::all_of(exist))
  } %>%
  add_total_and_avg_rows_counts(country_name_col = "Country")

readr::write_csv(tabN3_counts, "appendix_tableN3_COUNTS_CN_allpolicies_by_yeargroup.csv")

tabN3_lower <- c("Country", rep(c("Consumer","Non-Consumer"), times = length(year_labels)))
tabN3_upper <- make_upper_spanner(year_labels)
tabN3_tex <- tabN3_counts %>%
  kbl(format = "latex", booktabs = TRUE, longtable = TRUE, linesep = "",
      caption = "N3: All policies â€” counts by year-group (Consumer vs. Non-Consumer).",
      label   = "tabN:CN_all_counts_by_yeargroup",
      align   = c("l", rep("r", ncol(tabN3_counts) - 1)),
      escape  = FALSE,
      col.names = tabN3_lower) %>%
  add_header_above(tabN3_upper, escape = FALSE) %>%
  kable_styling(latex_options = c("hold_position","repeat_header","striped","scale_down"),
                stripe_color  = "gray!12", full_width = FALSE, font_size = 8) %>%
  column_spec(1, width = "2.0cm") %>%
  column_spec(2:ncol(tabN3_counts), width = "1.35cm") %>%
  row_spec(nrow(tabN3_counts)-1, bold = TRUE) %>%
  row_spec(nrow(tabN3_counts), bold = TRUE, background = "gray!08")
writeLines(tabN3_tex, "appendix_tableN3_COUNTS_CN_allpolicies_by_yeargroup.tex")
```


# 3.2 Subsidies Spending & Greenhouse Gas Emissions
```{r}
# ============================================================
# Subsidy Adoptions / Subsidy Spending (mit Real- und PPP-Korrektur)
# (Anzeige: "Fiscal Support adoptions"; Speicher-/Variablennamen unverÃ¤ndert)
# ============================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(readr)
  library(stringr)
  library(purrr)
  library(ggplot2)
  library(scales)
  library(janitor)
})

label_short <- function(...) {
  scales::label_number(scale_cut = scales::cut_short_scale(), ...)
}

if (!exists("country_col")) country_col <- "country"
if (!exists("year_col"))    year_col    <- "year"
stopifnot("Datensatz 'all_policies_std' nicht gefunden." = exists("all_policies_std"))

in_dir <- input_dir
stopifnot(dir.exists(in_dir))
file_spend  <- file.path(in_dir, "f03910ba-fb96-4e2b-9208-77818d75c335_Data.csv")
file_wdi    <- file.path(in_dir, "44d60fb7-9af6-4359-b8c3-b30f7dd1db43_Data.csv")

norm_country <- function(x) {
  x %>%
    stringr::str_replace("^Korea,? Republic of$|^South Korea$", "Korea") %>%
    stringr::str_replace("^United States of America$|^USA$|^US$", "United States") %>%
    stringr::str_replace("^UK$|^Great Britain$", "United Kingdom") %>%
    stringr::str_replace("^Czechia$", "Czech Republic") %>%
    stringr::str_trim()
}

pivot_wdi_like <- function(df, value_col = "value_num") {
  year_cols <- grep("^x\\d{4}_yr\\d{4}$", names(df), value = TRUE)
  stopifnot("Keine Jahres-Spalten im Format xYYYY_yrYYYY gefunden." = length(year_cols) > 0)

  df %>%
    tidyr::pivot_longer(
      cols = dplyr::all_of(year_cols),
      names_to = "year_colname",
      values_to = "value_raw"
    ) %>%
    dplyr::mutate(
      !!year_col := stringr::str_extract(year_colname, "(?<=_yr)\\d{4}") %>% as.integer(),
      !!value_col := readr::parse_number(value_raw, locale = readr::locale(grouping_mark = ","))
    )
}

# 1) Spending (nominal LCU)
spend_raw <- readr::read_csv(file_spend) %>% janitor::clean_names()
spend_filtered <- spend_raw %>%
  dplyr::filter(series_name == "Subsidies and other transfers (current LCU)")
spend_long <- pivot_wdi_like(spend_filtered, value_col = "value_num")

spend_df_nominal <- spend_long %>%
  dplyr::transmute(
    !!country_col := norm_country(dplyr::coalesce(.data[["country_name"]], .data[["country_code"]]) %>% as.character()),
    !!year_col    := .data[[year_col]],
    subsidy_spending_lcu = value_num
  ) %>%
  dplyr::filter(dplyr::between(.data[[year_col]], 1990, 2022)) %>%
  dplyr::group_by(.data[[country_col]], .data[[year_col]]) %>%
  dplyr::summarise(subsidy_spending_lcu = sum(subsidy_spending_lcu, na.rm = TRUE), .groups = "drop")

# 23 ReferenzlÃ¤nder
countries_ref <- all_policies_std %>%
  dplyr::mutate(!!country_col := norm_country(.data[[country_col]])) %>%
  dplyr::distinct(!!sym(country_col)) %>%
  dplyr::arrange(!!sym(country_col))
n_ref <- nrow(countries_ref)
message(sprintf("ReferenzlÃ¤nder (Policies): %d gefunden.", n_ref))
if (n_ref != 23) warning(sprintf("Erwartet: 23 LÃ¤nder, gefunden: %d.", n_ref))

spend_df_nominal <- spend_df_nominal %>%
  dplyr::semi_join(countries_ref, by = setNames(country_col, country_col))

years_ref <- all_policies_std %>%
  dplyr::mutate(!!year_col := as.integer(.data[[year_col]])) %>%
  dplyr::filter(dplyr::between(.data[[year_col]], 1990, 2022)) %>%
  dplyr::distinct(!!sym(year_col))

spend_df_nominal <- spend_df_nominal %>%
  dplyr::semi_join(years_ref, by = setNames(year_col, year_col))

# 2) WDI-Hilfsdaten
wdi_raw <- readr::read_csv(file_wdi) %>% janitor::clean_names()
wdi_long <- pivot_wdi_like(wdi_raw, value_col = "value_num") %>%
  dplyr::transmute(
    !!country_col := norm_country(dplyr::coalesce(.data[["country_name"]], .data[["country_code"]]) %>% as.character()),
    !!year_col    := .data[[year_col]],
    series_name   = .data[["series_name"]],
    value_num     = .data[["value_num"]]
  ) %>%
  dplyr::filter(dplyr::between(.data[[year_col]], 1990, 2022)) %>%
  dplyr::semi_join(countries_ref, by = setNames(country_col, country_col))

gdp_defl <- wdi_long %>% dplyr::filter(stringr::str_detect(series_name, "(?i)^gdp deflator")) %>%
  dplyr::select(!!sym(country_col), !!sym(year_col), gdp_deflator = value_num)
cpi_2010 <- wdi_long %>% dplyr::filter(stringr::str_detect(series_name, "(?i)^consumer price index.*2010")) %>%
  dplyr::select(!!sym(country_col), !!sym(year_col), cpi_2010 = value_num)
ppp_conv <- wdi_long %>% dplyr::filter(stringr::str_detect(series_name, "(?i)^ppp conversion factor, gdp")) %>%
  dplyr::select(!!sym(country_col), !!sym(year_col), ppp_lcu_per_intl = value_num)
fx_official <- wdi_long %>% dplyr::filter(stringr::str_detect(series_name, "(?i)^official exchange rate.*lcu per usd")) %>%
  dplyr::select(!!sym(country_col), !!sym(year_col), fx_lcu_per_usd = value_num)

# 3) Real-/PPP-Umrechnung
spend_corr <- spend_df_nominal %>%
  dplyr::left_join(gdp_defl,   by = setNames(c(country_col, year_col), c(country_col, year_col))) %>%
  dplyr::left_join(cpi_2010,   by = setNames(c(country_col, year_col), c(country_col, year_col))) %>%
  dplyr::left_join(ppp_conv,   by = setNames(c(country_col, year_col), c(country_col, year_col))) %>%
  dplyr::left_join(fx_official,by = setNames(c(country_col, year_col), c(country_col, year_col))) %>%
  dplyr::mutate(
    deflator_index = dplyr::coalesce(gdp_deflator, cpi_2010),
    subsidy_spending_real_lcu =
      dplyr::if_else(is.finite(deflator_index) & deflator_index > 0,
                     subsidy_spending_lcu / (deflator_index / 100), NA_real_),
    subsidy_spending_real_ppp =
      dplyr::if_else(is.finite(ppp_lcu_per_intl) & ppp_lcu_per_intl > 0,
                     subsidy_spending_real_lcu / ppp_lcu_per_intl, NA_real_),
    subsidy_spending_real_usd =
      dplyr::if_else(is.finite(fx_lcu_per_usd) & fx_lcu_per_usd > 0,
                     subsidy_spending_real_lcu / fx_lcu_per_usd, NA_real_)
  )

spend_df <- spend_corr %>% dplyr::rename(subsidy_spending = subsidy_spending_real_ppp)

# 4) Policy-Counts (nur Subsidy â†’ Anzeige â€žFiscal Support adoptionsâ€œ)
pol <- all_policies_std %>%
  filter(.data[["dataset"]] == "Subsidy") %>%
  mutate(
    !!country_col := norm_country(.data[[country_col]]),
    !!year_col    := as.integer(.data[[year_col]])
  )

if (!"dist2" %in% names(pol)) {
  ig <- if ("income_group" %in% names(pol)) "income_group" else NA_character_
  if (is.na(ig)) {
    warning("Keine 'dist2' und keine 'income_group' Spalte gefunden; Dist2-Varianten werden Ã¼bersprungen.")
    pol$dist2 <- NA_character_
  } else {
    pol <- pol %>%
      mutate(
        dist2 = case_when(
          .data[[ig]] == "Higher income" ~ "Regressive",
          .data[[ig]] %in% c("Lower income", "All incomes equally") ~ "Progressive",
          TRUE ~ NA_character_
        )
      )
  }
}

count_policies <- function(df, filter_expr = TRUE) {
  df %>%
    filter({{ filter_expr }}) %>%
    count(!!sym(country_col), !!sym(year_col), name = "n_subsidy") %>%
    ungroup()
}

counts_all        <- count_policies(pol, TRUE)
counts_cons       <- count_policies(pol, target == "Consumer")
counts_noncons    <- count_policies(pol, target == "Non-Consumer")
counts_prog       <- count_policies(pol, !is.na(dist2) & dist2 == "Progressive")
counts_regr       <- count_policies(pol, !is.na(dist2) & dist2 == "Regressive")

# 5) Ratio = Counts / Spending
make_ratio <- function(count_df, spend_df, label_suffix, spend_var = "subsidy_spending") {
  stopifnot(spend_var %in% names(spend_df))
  out <- spend_df %>%
    dplyr::select(!!sym(country_col), !!sym(year_col), !!sym(spend_var)) %>%
    dplyr::rename(subsidy_spending = !!sym(spend_var)) %>%
    dplyr::left_join(count_df, by = setNames(c(country_col, year_col), c(country_col, year_col))) %>%
    dplyr::mutate(
      n_subsidy = dplyr::coalesce(n_subsidy, 0L),
      ratio = dplyr::if_else(is.finite(subsidy_spending) & subsidy_spending != 0,
                             n_subsidy / subsidy_spending, NA_real_)
    )
  list(data = out, label = label_suffix, spend_var = spend_var)
}

rat_all     <- make_ratio(counts_all,     spend_df, "all_PPP",         spend_var = "subsidy_spending")
rat_cons    <- make_ratio(counts_cons,    spend_df, "consumer_PPP",    spend_var = "subsidy_spending")
rat_noncons <- make_ratio(counts_noncons, spend_df, "nonconsumer_PPP", spend_var = "subsidy_spending")
rat_prog    <- make_ratio(counts_prog,    spend_df, "progressive_PPP", spend_var = "subsidy_spending")
rat_regr    <- make_ratio(counts_regr,    spend_df, "regressive_PPP",  spend_var = "subsidy_spending")

rat_all_LCU  <- make_ratio(counts_all, spend_corr, "all_LCU",  spend_var = "subsidy_spending_lcu")
rat_all_USD  <- make_ratio(counts_all, spend_corr, "all_USD",  spend_var = "subsidy_spending_real_usd")

# 6) Wide-Tabellen (Dateinamen UNVERÃ„NDERT lassen)
to_wide <- function(ratio_obj, file_stub) {
  wide <- ratio_obj$data %>%
    dplyr::select(!!sym(country_col), !!sym(year_col), ratio) %>%
    dplyr::filter(dplyr::between(.data[[year_col]], 1990, 2022)) %>%
    dplyr::mutate(year_chr = as.character(.data[[year_col]])) %>%
    dplyr::select(-!!sym(year_col)) %>%
    tidyr::pivot_wider(names_from = year_chr, values_from = ratio) %>%
    dplyr::arrange(.data[[country_col]])
  out_path <- sprintf("%s_ratio_subsidy_per_spending_WIDE.csv", file_stub)
  readr::write_csv(wide, out_path)
  message(sprintf("Wide-Tabelle gespeichert: %s", out_path))
  return(wide)
}

wide_all     <- to_wide(rat_all,     "ALL_PPP")
wide_cons    <- to_wide(rat_cons,    "CONS_PPP")
wide_noncons <- to_wide(rat_noncons, "NONCONS_PPP")
wide_prog    <- to_wide(rat_prog,    "PROG_PPP")
wide_regr    <- to_wide(rat_regr,    "REGR_PPP")
invisible(to_wide(rat_all_LCU, "ALL_LCU"))
invisible(to_wide(rat_all_USD, "ALL_USD"))

# 7) Scatterplots (Anzeige-Strings angepasst)
scatter_counts_vs_spending <- function(count_df, base_spend_df, title, file_stub,
                                       spend_var = "subsidy_spending",
                                       log_axes = FALSE, point_alpha = 0.4) {
  stopifnot(spend_var %in% names(base_spend_df))
  df <- base_spend_df %>%
    dplyr::select(!!sym(country_col), !!sym(year_col), !!sym(spend_var)) %>%
    dplyr::rename(subsidy_spending = !!sym(spend_var)) %>%
    dplyr::left_join(count_df, by = setNames(c(country_col, year_col), c(country_col, year_col))) %>%
    dplyr::mutate(n_subsidy = dplyr::coalesce(n_subsidy, 0L)) %>%
    dplyr::filter(is.finite(subsidy_spending), subsidy_spending > 0)

  p <- ggplot(df, aes(x = subsidy_spending, y = n_subsidy)) +
    geom_point(alpha = point_alpha) +
    geom_smooth(method = "lm", se = TRUE) +
    labs(
      x = sprintf("Subsidy spending (%s)", spend_var),
      y = "# Fiscal Support adoptions",
      title = title,
      subtitle = "Country-year observations (1990â€“2022)"
    ) +
    theme_minimal(base_size = 11)

  if (log_axes) {
    p <- p + scale_x_log10(labels = label_short()) + scale_y_log10(labels = label_short())
  } else {
    p <- p + scale_x_continuous(labels = label_short()) + scale_y_continuous(labels = label_short())
  }

  print(p)
  ggsave(sprintf("%s_scatter_spending_vs_counts_%s.pdf", file_stub, spend_var), p,
         width = 7.2, height = 5.0, units = "in")
  invisible(df)
}

# Standard: Real PPP (TITEL angepasst)
df_sc_all_PPP  <- scatter_counts_vs_spending(counts_all,  spend_corr,
                   "Spending (Real PPP) vs. # Fiscal Support adoptions (ALL)",
                   "ALL", spend_var = "subsidy_spending_real_ppp", log_axes = FALSE)

df_sc_cons_PPP <- scatter_counts_vs_spending(counts_cons, spend_corr,
                   "Spending (Real PPP) vs. # Fiscal Support adoptions (Consumer)",
                   "CONS", spend_var = "subsidy_spending_real_ppp", log_axes = FALSE)

df_sc_non_PPP  <- scatter_counts_vs_spending(counts_noncons, spend_corr,
                   "Spending (Real PPP) vs. # Fiscal Support adoptions (Non-Consumer)",
                   "NONCONS", spend_var = "subsidy_spending_real_ppp", log_axes = FALSE)

if (any(!is.na(pol$dist2))) {
  df_sc_prog_PPP <- scatter_counts_vs_spending(counts_prog, spend_corr,
                       "Spending (Real PPP) vs. # Fiscal Support adoptions (Dist2: Progressive)",
                       "PROG", spend_var = "subsidy_spending_real_ppp", log_axes = FALSE)
  df_sc_regr_PPP <- scatter_counts_vs_spending(counts_regr, spend_corr,
                       "Spending (Real PPP) vs. # Fiscal Support adoptions (Dist2: Regressive)",
                       "REGR", spend_var = "subsidy_spending_real_ppp", log_axes = FALSE)
}

# Diagnose: nominal/real USD (TITEL angepasst)
invisible(scatter_counts_vs_spending(counts_all, spend_corr,
           "Spending (Nominal LCU) vs. # Fiscal Support adoptions (ALL)",
           "ALL", spend_var = "subsidy_spending_lcu", log_axes = FALSE))

invisible(scatter_counts_vs_spending(counts_all, spend_corr,
           "Spending (Real USD) vs. # Fiscal Support adoptions (ALL)",
           "ALL", spend_var = "subsidy_spending_real_usd", log_axes = FALSE))

# 8) Scatter der VerhÃ¤ltniskennzahl (Anzeige-Strings angepasst)
scatter_ratio_vs_spending <- function(ratio_obj, title, file_stub, log_axes = TRUE) {
  df <- ratio_obj$data %>%
    dplyr::filter(is.finite(subsidy_spending), subsidy_spending > 0, is.finite(ratio))

  p <- ggplot(df, aes(x = subsidy_spending, y = ratio)) +
    geom_point(alpha = 0.4) +
    geom_smooth(method = "lm", se = TRUE) +
    labs(x = "Subsidy spending (x-axis units as chosen)",
         y = "Fiscal Support adoptions per spending unit",
         title = title,
         subtitle = "Country-year observations (1990â€“2022)") +
    theme_minimal(base_size = 11)

  if (log_axes) {
    p <- p + scale_x_log10(labels = label_short()) + scale_y_log10(labels = label_short())
  } else {
    p <- p + scale_x_continuous(labels = label_short()) + scale_y_continuous(labels = label_short())
  }

  print(p)
  ggsave(sprintf("%s_scatter_RATIO_vs_spending.pdf", file_stub), p,
         width = 7.2, height = 5.0, units = "in")
  invisible(df)
}

scatter_ratio_vs_spending(rat_all,  "Adoptions-per-spending (PPP-Real, ALL)",  "ALL_PPP")
scatter_ratio_vs_spending(rat_cons, "Adoptions-per-spending (PPP-Real, Consumer)", "CONS_PPP")
scatter_ratio_vs_spending(rat_noncons, "Adoptions-per-spending (PPP-Real, Non-Consumer)", "NONCONS_PPP")
if (any(!is.na(pol$dist2))) {
  scatter_ratio_vs_spending(rat_prog, "Adoptions-per-spending (PPP-Real, Dist2: Progressive)", "PROG_PPP")
  scatter_ratio_vs_spending(rat_regr, "Adoptions-per-spending (PPP-Real, Dist2: Regressive)", "REGR_PPP")
}

# 9) Kurz-LMs (nur Konsolen-Ausgabe â€“ unverÃ¤ndert)
quick_lm <- function(df, x = "subsidy_spending", y = "n_subsidy") {
  df2 <- df %>% filter(is.finite(.data[[x]]), is.finite(.data[[y]]))
  if (nrow(df2) >= 10) {
    m <- lm(reformulate(x, y), data = df2)
    s <- summary(m)
    cat(sprintf("\nLM %s ~ %s: n=%d, beta=%.3g, R2=%.3f, p=%.3g\n",
                y, x, nrow(df2), coef(m)[2], s$r.squared, coef(s)[2,4]))
  }
}

cat("\n=== Lineare Modelle: Counts ~ Spending (PPP-Real, kurzer Ãœberblick) ===\n")
purrr::walk(list(ALL = df_sc_all_PPP,
                 CONS = df_sc_cons_PPP,
                 NONC = df_sc_non_PPP),
            ~ quick_lm(.x, x = "subsidy_spending", y = "n_subsidy"))

if (exists("df_sc_prog_PPP")) {
  purrr::walk(list(PROG = df_sc_prog_PPP,
                   REGR = df_sc_regr_PPP),
              ~ quick_lm(.x, x = "subsidy_spending", y = "n_subsidy"))
}
```

## 3er OLS Plot neu mit Farbschema
```{r}
# ============================================================
# A4-Triptychon: Subsidy Spending (PPP, real) vs. Fiscal Support adoptions
# - Oben: ALL (Subsidy-Blau), OHNE Konfidenzband
# - Unten: Consumer vs Non-consumer / Progressive vs Regressive (jeweils OHNE Konfidenzband)
# - Top-Panel etwas kleiner (0.9 : 1.1)
# - Dateiname unverÃ¤ndert
# ============================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(ggplot2)
  library(scales)
  library(patchwork)
})

# --- Farbdefinitionen --------------------------------------------------------
col_subsidy_all   <- "#4C9BE8"
col_consumer      <- "#4C9BE8"
col_nonconsumer   <- "#1E6BB8"
col_progressive   <- "#4C9BE8"
col_regressive    <- "#C0392B"

# --- Hilfsformatter ----------------------------------------------------------
label_short <- function(...) {
  scales::label_number(scale_cut = scales::cut_short_scale(), ...)
}
fmt_p <- function(p) ifelse(is.na(p), "p = NA",
                            ifelse(p < 1e-4, "p < 1e-4",
                                   paste0("p = ", formatC(p, format = "fg", digits = 2))))
fmt_r2 <- function(r2) sprintf("R^2 = %.3f", r2)
fmt_slope_per_10B <- function(beta_bil) {
  per10B <- beta_bil * 10
  if (is.na(per10B)) return("Slope = NA")
  if (abs(per10B) < 0.01) return("Slope < 0.01 adoptions / $10B")
  sprintf("Slope â‰ˆ %.2f adoptions / $10B", per10B)
}

# --- Oberes Panel (OHNE CI) --------------------------------------------------
build_scatter_top <- function(df,
                              title = "All Fiscal Support adoptions vs. real PPP subsidy spending",
                              x_lab = "Real subsidy spending (PPP, 2017=100, $ billions)",
                              y_lab = "# Fiscal Support adoptions",
                              point_alpha = 0.20, point_size = 1.6, line_size = 0.8) {

  d <- df %>%
    filter(is.finite(subsidy_spending), is.finite(n_subsidy), subsidy_spending > 0) %>%
    mutate(spend_bil = subsidy_spending / 1e9)

  m <- lm(n_subsidy ~ spend_bil, data = d)
  s <- summary(m)
  subtitle <- paste(fmt_r2(s$r.squared),
                    fmt_p(coef(s)[2, 4]),
                    fmt_slope_per_10B(coef(m)[2]),
                    sep = "  â€¢  ")

  ggplot(d, aes(x = spend_bil, y = n_subsidy)) +
    geom_point(alpha = point_alpha, size = point_size, color = col_subsidy_all) +
    geom_smooth(method = "lm", se = FALSE, size = line_size, color = col_subsidy_all) +  # << CI aus
    labs(title = title, subtitle = subtitle, x = x_lab, y = y_lab) +
    scale_x_continuous(labels = label_dollar(prefix = "$", suffix = "B", accuracy = 1)) +
    scale_y_continuous(labels = label_short()) +
    theme_minimal(base_size = 11) +
    theme(
      legend.position = "none",
      plot.title.position = "plot",
      plot.subtitle = element_text(color = "grey20", size = 8),
      panel.grid.minor = element_blank()
    )
}

# --- Untere Panels (zwei Serien, OHNE CI) -----------------------------------
build_scatter_dual <- function(df_a, df_b,
                               label_a, label_b,
                               col_a, col_b,
                               title,
                               x_lab = "Real subsidy spending (PPP, 2017=100, $ billions)",
                               y_lab = "# Fiscal Support adoptions",
                               point_alpha = 0.22,
                               point_size  = 1.4,
                               line_size   = 0.8) {

  prep <- function(d, lab) {
    d %>%
      filter(is.finite(subsidy_spending),
             is.finite(n_subsidy),
             subsidy_spending > 0) %>%
      mutate(spend_bil = subsidy_spending / 1e9,
             group = lab)
  }

  D <- bind_rows(prep(df_a, label_a), prep(df_b, label_b)) %>%
    mutate(group = factor(group, levels = c(label_a, label_b)))

  ggplot(D, aes(x = spend_bil, y = n_subsidy, color = group)) +
    geom_point(alpha = point_alpha, size = point_size) +
    geom_smooth(method = "lm", se = FALSE, size = line_size) +  # << CI aus
    scale_color_manual(
      values = setNames(c(col_a, col_b), c(label_a, label_b)),
      name = NULL
    ) +
    labs(title = title, x = x_lab, y = y_lab) +
    scale_x_continuous(labels = label_dollar(prefix = "$", suffix = "B", accuracy = 1)) +
    scale_y_continuous(labels = label_short()) +
    theme_minimal(base_size = 11) +
    theme(
      plot.title = element_text(size = 9, face = "bold"),
      legend.position = "top",
      legend.text = element_text(size = 9),
      plot.title.position = "plot",
      panel.grid.minor = element_blank()
    )
}

# --- Daten prÃ¼fen ------------------------------------------------------------
stopifnot(
  exists("df_sc_all_PPP"),
  exists("df_sc_cons_PPP"),
  exists("df_sc_non_PPP"),
  exists("df_sc_prog_PPP"),
  exists("df_sc_regr_PPP")
)

# --- Plots erzeugen ----------------------------------------------------------
p_top <- build_scatter_top(df_sc_all_PPP)

p_target <- build_scatter_dual(
  df_a = df_sc_cons_PPP,
  df_b = df_sc_non_PPP,
  label_a = "Consumer",
  label_b = "Non-consumer",
  col_a = col_consumer,
  col_b = col_nonconsumer,
  title = "Consumer vs. Non-consumer Fiscal Support adoptions"
)

p_dist <- build_scatter_dual(
  df_a = df_sc_prog_PPP,
  df_b = df_sc_regr_PPP,
  label_a = "Progressive",
  label_b = "Regressive",
  col_a = col_progressive,
  col_b = col_regressive,
  title = "Progressive vs. Regressive Fiscal Support adoptions"
)

# --- Layout: Top kleiner (0.9 : 1.1) ----------------------------------------
layout <- p_top / (p_target | p_dist) +
  plot_layout(heights = c(0.9, 1.1)) +
  plot_annotation(
    title = "Fiscal capacity and Fiscal Support adoptions",
    theme = theme(plot.title = element_text(face = "bold", size = 11))
  )

# --- Export ------------------------------------------------------------------
ggsave(
  filename = "A4_triptych_spending_vs_counts_PPP.pdf",
  plot = layout,
  width = 8.27, height = 11.69, units = "in"
)
```

### Depriciated Vergleich ohne USA/Australia (robustness)
```{r exclude_US_AUS_check, message=FALSE, warning=FALSE}
# ============================================================
# Spezifikation/Diagnose: Treiben US & AUS den Non-consumer-Effekt?
# - Per-Country OLS: beta/R^2/p (Non-consumer)
# - Leave-one-out (LOO): Î”Slope% & Î”R^2 je ausgeschlossenem Land
# - Richtung (positiv/negativ) fÃ¼r Consumer vs Non-consumer
# - Kompakte Text-Ausgaben + optionaler Plot + CSV
# Voraussetzung: df_sc_non_PPP (und optional df_sc_cons_PPP), country_col
# ============================================================

suppressPackageStartupMessages({
  library(dplyr); library(purrr); library(ggplot2); library(readr)
})

# ---------- Hilfen ----------
dir_str <- function(b) {
  if (!is.finite(b) || abs(b) < 1e-12) return("zero")
  if (b > 0) "positive" else "negative"
}
fit_stats_simple <- function(d) {
  d <- d %>% filter(is.finite(subsidy_spending), subsidy_spending > 0,
                    is.finite(n_subsidy)) %>%
             mutate(spend_bil = subsidy_spending/1e9)
  if (nrow(d) < 10) return(list(beta_per_10B = NA_real_, r2 = NA_real_, p = NA_real_))
  m <- lm(n_subsidy ~ spend_bil, data = d)
  s <- summary(m)
  list(beta_per_10B = unname(coef(m)[2]) * 10,
       r2 = unname(s$r.squared),
       p  = unname(coef(s)[2,4]))
}

# ---------- (A) Per-Country OLS fÃ¼r NON-CONSUMER ----------
if (!exists("df_sc_non_PPP")) stop("df_sc_non_PPP fehlt fÃ¼r die Non-consumer-Diagnose.")
df_non_base <- df_sc_non_PPP %>%
  filter(is.finite(subsidy_spending), subsidy_spending > 0, is.finite(n_subsidy)) %>%
  mutate(spend_bil = subsidy_spending/1e9)

per_country_non <- df_non_base %>%
  group_by(!!sym(country_col)) %>%
  group_map(~{
    if (nrow(.x) >= 6) {
      m <- lm(n_subsidy ~ spend_bil, data = .x)
      s <- summary(m)
      tibble(
        !!country_col := unique(.x[[country_col]]),
        n = nrow(.x),
        beta_per_10B = unname(coef(m)[2]) * 10,
        r2 = unname(s$r.squared),
        p  = unname(coef(s)[2,4])
      )
    } else tibble(!!country_col := unique(.x[[country_col]]), n = nrow(.x),
                  beta_per_10B = NA_real_, r2 = NA_real_, p = NA_real_)
  }) %>% bind_rows() %>% arrange(desc(r2))

# Ausgabe Top-LÃ¤nder nach R^2 (zeigt â€žTrÃ¤gerâ€œ der Beziehung)
cat("\n--- Non-consumer: per-country OLS (Top by R^2) ---\n")
print(per_country_non %>% arrange(desc(r2)) %>% head(10))

# ---------- (B) Leave-one-out (LOO) fÃ¼r NON-CONSUMER ----------
countries <- sort(unique(df_non_base[[country_col]]))
# Full-Fit (baseline)
full_stats_non <- fit_stats_simple(df_non_base)
full_beta <- full_stats_non$beta_per_10B; full_r2 <- full_stats_non$r2

loo_non <- map_dfr(countries, function(cty){
  d_ex <- df_non_base %>% filter(.data[[country_col]] != cty)
  st <- fit_stats_simple(d_ex)
  tibble(
    excluded_country = cty,
    beta_per_10B_excl = st$beta_per_10B,
    r2_excl = st$r2,
    p_excl  = st$p,
    delta_slope_pct = if (is.finite(full_beta) && full_beta != 0 && is.finite(st$beta_per_10B))
                        100 * (st$beta_per_10B - full_beta) / abs(full_beta) else NA_real_,
    delta_r2_pct    = if (is.finite(full_r2) && full_r2 > 0 && is.finite(st$r2))
                        100 * (st$r2 - full_r2) / full_r2 else NA_real_
  )
}) %>% arrange(delta_slope_pct)

# CSV (optional) + kompakte Ausgabe der Top-EinflÃ¼sse
readr::write_csv(loo_non, "NONCONS_LOO_influence.csv")
cat("\n--- Non-consumer LOO: grÃ¶ÃŸte EinflÃ¼sse (Î”Slope%%, negativer Wert = Slope fÃ¤llt) ---\n")
print(loo_non %>%
        arrange(delta_slope_pct) %>%
        mutate(delta_slope_pct = round(delta_slope_pct, 1),
               delta_r2_pct = round(delta_r2_pct, 1)) %>%
        head(10))

# Markiere speziell US & AUS
cta <- c("United States","Australia")
if (all(cta %in% countries)) {
  row_US  <- loo_non %>% filter(excluded_country == "United States")
  row_AUS <- loo_non %>% filter(excluded_country == "Australia")
  cat("\n>>> Specific impact (Non-consumer):\n")
  cat(sprintf("- Exclude United States:  Î”Slope=%.1f%%, Î”RÂ²=%.1f%%\n",
              row_US$delta_slope_pct, row_US$delta_r2_pct))
  cat(sprintf("- Exclude Australia:     Î”Slope=%.1f%%, Î”RÂ²=%.1f%%\n",
              row_AUS$delta_slope_pct, row_AUS$delta_r2_pct))
}

# Kleiner Einfluss-Plot (optional)
p_loo <- loo_non %>%
  mutate(tag = ifelse(excluded_country %in% c("United States","Australia"), "US/AUS", "Other")) %>%
  arrange(delta_slope_pct) %>%
  mutate(excluded_country = factor(excluded_country, levels = excluded_country)) %>%
  ggplot(aes(x = excluded_country, y = delta_slope_pct, fill = tag)) +
  geom_col() +
  coord_flip() +
  labs(title = "LOO influence on slope (Non-consumer): Î”Slope% when excluding country",
       x = "Excluded country", y = "Î” Slope (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position = "none")
ggsave("NONCONS_LOO_deltaSlope_barplot.pdf", p_loo, width = 7.2, height = 6.0, units = "in")

# ---------- (C) Richtung (positiv/negativ) fÃ¼r Consumer vs Non-consumer ----------
# Richtung = Vorzeichen der Steigung (beta_per_10B), Full vs Excl(US&AUS)
dir_report <- function(df, label) {
  st_full <- fit_stats_simple(df)
  st_excl <- fit_stats_simple(df %>% filter(!.data[[country_col]] %in% c("United States","Australia")))
  cat(sprintf("\n>>> Direction (%s): FULL=%s, EXCL.US&AUS=%s\n",
              label, dir_str(st_full$beta_per_10B), dir_str(st_excl$beta_per_10B)))
  invisible(list(full = st_full, excl = st_excl))
}

# Non-consumer Richtung
dir_non <- dir_report(df_sc_non_PPP, "Non-consumer")

# Consumer (falls vorhanden)
if (exists("df_sc_cons_PPP")) {
  dir_cons <- dir_report(df_sc_cons_PPP, "Consumer")
} else {
  cat("\n(Note) df_sc_cons_PPP not available â€” Consumer direction skipped.\n")
}

cat("\n>>> Zusatz-Outputs gespeichert als: NONCONS_LOO_influence.csv, NONCONS_LOO_deltaSlope_barplot.pdf\n")


# --- Diagnose: Wird die Beziehung durch US & AUS getrieben? -------------------
is_sig <- function(p) is.finite(p) && p < 0.05

diagnose_driven <- function(full, excl) {
  # Schutz
  if (any(is.null(full), is.null(excl))) return("n/a")
  b_full <- full$beta_per_10B; b_excl <- excl$beta_per_10B
  r2_full <- full$r2; r2_excl <- excl$r2; p_full <- full$p; p_excl <- excl$p

  sign_flip   <- is.finite(b_full) && is.finite(b_excl) && sign(b_full) != sign(b_excl) && b_full != 0 && b_excl != 0
  sig_loss    <- is_sig(p_full) && !is_sig(p_excl)
  big_drop_b  <- is.finite(b_full) && b_full != 0 && is.finite(b_excl) &&
                 (abs(b_excl) < 0.5 * abs(b_full))
  big_drop_r2 <- is.finite(r2_full) && r2_full > 0 && is.finite(r2_excl) &&
                 ((r2_full - r2_excl) / r2_full > 0.30)

  if (sign_flip || sig_loss || big_drop_b || big_drop_r2) "LIKELY driven by US & AUS"
  else "Robust (not driven by US & AUS)"
}

```


## Country Plots
### Aufbereitung: Datenpipeline fÃ¼r SubventionszÃ¤hlungen und PPP-Ausgaben (1990â€“2022)
```{r}
# --- Setup (nur falls noch nicht geladen) ---
suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(stringr); library(readr)
})

# Defaults, falls nicht gesetzt
START_YEAR <- get0("START_YEAR", ifnotfound = 1990)
END_YEAR   <- get0("END_YEAR",   ifnotfound = 2022)

# Guards
stopifnot("Datensatz 'all_policies_std' fehlt." = exists("all_policies_std"))

# Namens-Normierung wie in deinen Chunks
norm_country <- function(x){
  x %>%
    str_replace("^Korea,? Rep\\.?$|^Republic of Korea$|^Korea,? Republic of$|^South Korea$", "Korea") %>%
    str_replace("^United States of America$|^USA$|^US$", "United States") %>%
    str_replace("^UK$|^Great Britain$", "United Kingdom") %>%
    str_replace("^Czechia$", "Czech Republic") %>%
    str_trim()
}

# --- pol0: Subsidy-Policies 1990â€“2022 ---
pol0 <- all_policies_std %>%
  mutate(country = norm_country(country),
         year    = as.integer(year)) %>%
  filter(dataset == "Subsidy",
         dplyr::between(year, START_YEAR, END_YEAR))

message("n rows in pol0 = ", nrow(pol0))

# ===== PRÃœFUNGEN (robust) =====

# 1) SichtprÃ¼fung: absolute HÃ¤ufigkeiten je Kategorie (Consumer/Non-Consumer)
quick_cn <- pol0 %>% count(target, name = "n") %>% arrange(desc(n))
print(quick_cn)

# 2) Distributive Rohkategorien (nur Consumer; income_group aus Subsidies)
quick_dist <- pol0 %>%
  filter(target == "Consumer") %>%
  mutate(dist_raw = as.character(income_group) %>% trimws()) %>%
  count(dist_raw, name = "n") %>%
  arrange(desc(n))
print(quick_dist)

# 3) LÃ¤nder-Ãœbersicht: hat ein Land 0 Consumer?
#    -> erzwinge Spalten 'Consumer' und 'Non-Consumer', selbst wenn Counts = 0
by_country_cn <- pol0 %>%
  count(country, target, name = "n") %>%
  tidyr::complete(country, target = c("Consumer","Non-Consumer"), fill = list(n = 0)) %>%
  tidyr::pivot_wider(names_from = target, values_from = n, values_fill = 0) %>%
  arrange(dplyr::desc(Consumer))   # jetzt existiert 'Consumer' garantiert
print(by_country_cn %>% slice(1:10))

# 4) Zeitlicher Verlauf: tauchen Consumers erst spÃ¤t auf?
by_year_cn <- pol0 %>%
  count(year, target, name = "n") %>%
  tidyr::complete(year, target = c("Consumer","Non-Consumer"), fill = list(n = 0)) %>%
  tidyr::pivot_wider(names_from = target, values_from = n, values_fill = 0) %>%
  arrange(year)
print(by_year_cn)

# 5) Stichprobe: 'instrument' sicher bauen (nur aus vorhandenen Spalten)
instr_cols <- intersect(c("policy_name","instrument","measure","title","policy_title"),
                        names(pol0))

tmp_cons <- pol0 %>%
  dplyr::filter(target %in% c("Consumer","Non-Consumer")) %>%
  # coalesce nur Ã¼ber vorhandene Spalten
  dplyr::mutate(
    instrument = if (length(instr_cols)) dplyr::coalesce(!!!dplyr::select(., dplyr::all_of(instr_cols)))
                 else NA_character_
  ) %>%
  dplyr::select(country, year, instrument, target)

# konstante StichprobengrÃ¶ÃŸe bestimmen
n_take <- min(20L, nrow(tmp_cons))

set.seed(123)  # optional fÃ¼r Reproduzierbarkeit
sample_cons <- if (n_take > 0) dplyr::slice_sample(tmp_cons, n = n_take) else tmp_cons

print(sample_cons)

# 6) Distributive 3er-Mapping (Consumer Subsidies): Progressive / Targeted / Regressive
dist3_counts <- pol0 %>%
  filter(target == "Consumer") %>%
  mutate(dist_raw = as.character(income_group) %>% trimws(),
         dist3 = dplyr::case_when(
           dist_raw == "Lower income"         ~ "Progressive",
           dist_raw == "All incomes equally"  ~ "Targeted",
           dist_raw == "Higher income"        ~ "Regressive",
           TRUE ~ NA_character_
         )) %>%
  count(dist3, name = "n") %>%
  arrange(desc(n))
print(dist3_counts)

# Hinweise, falls â€žfast keine Consumer/Progressiveâ€œ:
if (nrow(quick_cn) && (is.na(quick_cn$n[quick_cn$target=="Consumer"]) || quick_cn$n[quick_cn$target=="Consumer"] == 0)) {
  message("âš ï¸ Keine/kaum Consumer-Policies in pol0. PrÃ¼fe target-Codierung, Filter dataset=='Subsidy' und die Jahre ", START_YEAR, "-", END_YEAR, ".")
}
if (nrow(quick_dist) && all(is.na(quick_dist$dist_raw) | quick_dist$dist_raw=="")) {
  message("âš ï¸ 'income_group' kaum befÃ¼llt. Dann erscheinen Progressive/Regressive naturgemÃ¤ÃŸ sehr niedrig.")
}

```
### Ausgabe: LÃ¤ndervergleich 1990â€“2022 â€” kumulative SubventionszÃ¤hlungen vs. kumulative PPP-Ausgaben (A4)
```{r}
# =========================================================
# A4 â€” TWO PANELS (STACKED BARS) + ADJACENT SPENDING BAR
# Panel 1: Cumulative SUBSIDY counts (Consumer vs Non-Consumer) + cumulative spend (PPP)
# Panel 2: Cumulative CONSUMER SUBSIDY counts (Progressive vs Regressive) + cumulative spend (PPP)
# Years: 1990â€“2022 (END_YEAR fixed at 2022)
# Exports: PDFs + CSVs + LaTeX tables (.tex)
# Includes diagnostics to verify counts composition
# =========================================================

suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(stringr); library(readr)
  library(ggplot2); library(scales); library(janitor)
  library(knitr); library(kableExtra); library(patchwork)
})

# -------- Parameters / Guards ----------
A4W  <- 8.27; A4H <- 11.69
START_YEAR <- get0("START_YEAR", ifnotfound = 1990)
END_YEAR   <- 2022
SAVE_DIR   <- getOption("mix_save_dir", default = ".")
if (!dir.exists(SAVE_DIR)) dir.create(SAVE_DIR, recursive = TRUE, showWarnings = FALSE)

stopifnot("all_policies_std fehlt." = exists("all_policies_std"))
# Aus dem Spending-Code: spend_corr (mit subsidy_spending_real_ppp) ODER spend_df (Alias)
if (!exists("spend_corr") && !exists("spend_df"))
  stop("Erwarte 'spend_corr' ODER 'spend_df' (siehe Spending-Code).")

# Normalisiere LÃ¤nder-Namen wie im Rest
norm_country <- function(x){
  x %>%
    str_replace("^Korea,? Rep\\.?$|^Republic of Korea$|^Korea,? Republic of$|^South Korea$", "Korea") %>%
    str_replace("^United States of America$|^USA$|^US$", "United States") %>%
    str_replace("^UK$|^Great Britain$", "United Kingdom") %>%
    str_replace("^Czechia$", "Czech Republic") %>%
    str_trim()
}

# Farben & Geometrie
col_CN   <- c("Consumer"="#4C9BE8", "Non-Consumer"="#1E6BB8")
col_DIST <- c("Progressive"="#4C9BE8","Regressive"="#C0392B")

# (5) Spending-Farbe (neu, grÃ¼n) + Legendeneintrag MIT Einheit
spending_legend_label <- "Cumulative subsidy spending (PPP, constant USD)"
emiss_spend_col <- "#31a354"  # aus {"#74c476", "#31a354", "#006d2c"}

# (2) Balkengeometrie wie Vorlage, Overlap vermeiden
BAR_W     <- 0.45
INNER_GAP <- 0.05
EM_SHIFT  <- BAR_W + INNER_GAP
if (EM_SHIFT + BAR_W > 1) {
  INNER_GAP <- max(0, 1 - 2*BAR_W - 1e-6)
  EM_SHIFT  <- BAR_W + INNER_GAP
  message(sprintf("INNER_GAP auto-adjusted to %.3f to avoid overlap.", INNER_GAP))
}
OUTER_GAP <- max(1 - (EM_SHIFT + BAR_W), 0.05)
EM_W      <- BAR_W

# -------- Spending (PPP, real) vorbereiten ----------
# Bevorzugt spend_corr$subsidy_spending_real_ppp; fallback spend_df$subsidy_spending
spend_base <- if (exists("spend_corr")) {
  spend_corr %>%
    transmute(country = norm_country(!!sym(if ("country" %in% names(.)) "country" else "country_name")),
              year    = !!sym(if ("year" %in% names(.)) "year" else "year"),
              subsidy_spending_real_ppp)
} else {
  spend_df %>%
    transmute(country = norm_country(country), year = year,
              subsidy_spending_real_ppp = subsidy_spending)
}

spend_ok <- spend_base %>%
  filter(between(as.integer(year), START_YEAR, END_YEAR)) %>%
  group_by(country) %>%
  summarise(spend_cum_ppp = sum(subsidy_spending_real_ppp, na.rm = TRUE), .groups = "drop")

# -------- Policy-Daten: Subsidies 1990â€“2022 ----------
pol0 <- all_policies_std %>%
  mutate(country = norm_country(country), year = as.integer(year)) %>%
  filter(dataset == "Subsidy", between(year, START_YEAR, END_YEAR))

# Panel 1: Consumer vs Non-Consumer (SUBSIDY, cumulated counts)
counts_CN <- pol0 %>%
  mutate(target = ifelse(target %in% c("Consumer","Non-Consumer"), target, NA_character_)) %>%
  filter(!is.na(target)) %>%
  count(country, target, name = "n") %>%
  tidyr::complete(country, target = c("Consumer","Non-Consumer"), fill = list(n = 0L)) %>%
  group_by(country) %>% mutate(total = sum(n)) %>% ungroup()

# (1) Panel 2: Distributive (Consumer-only) â€” Progressive (inkl. Targeted) vs Regressive
dist2 <- pol0 %>%
  filter(target == "Consumer") %>%
  mutate(dist_raw = as.character(income_group) %>% trimws()) %>%
  filter(!is.na(dist_raw), dist_raw != "Not applicable (non-consumer)") %>%
  mutate(
    dist2 = case_when(
      dist_raw %in% c("Lower income","All incomes equally") ~ "Progressive",  # Targeted -> Progressive
      dist_raw == "Higher income"                            ~ "Regressive",
      TRUE ~ NA_character_
    ),
    dist2 = factor(dist2, levels = c("Progressive","Regressive"))
  ) %>%
  count(country, dist2, name = "n") %>%
  tidyr::complete(country, dist2, fill = list(n = 0L)) %>%
  group_by(country) %>% mutate(total = sum(n)) %>% ungroup()

# -------- Merge: add cumulative spending next to bars ----------
# Panel 1 dataset
p1_df <- counts_CN %>%
  left_join(spend_ok, by = "country") %>%
  group_by(country) %>%
  mutate(spend_cum_ppp = first(spend_cum_ppp)) %>%
  ungroup()

# Panel 2 dataset
p2_df <- dist2 %>%
  left_join(spend_ok, by = "country") %>%
  group_by(country) %>%
  mutate(spend_cum_ppp = first(spend_cum_ppp)) %>%
  ungroup()

# -------- Secondary axis: map spending (PPP) â†’ counts scale ----------
make_scaler <- function(min_sec, max_sec, min_prim, max_prim){
  rng_sec  <- max(max_sec - min_sec, .Machine$double.eps)
  rng_prim <- max(max_prim - min_prim, .Machine$double.eps)
  a <- rng_prim / rng_sec
  list(
    fwd = function(x) min_prim + a*(x - min_sec),
    inv = function(y) min_sec   + (y - min_prim)/a
  )
}

# (4) Fixe Kappung ~ $40T (PPP, real)
cap_spend <- function(x, cap) pmin(x, cap)
cap_display_ppp <- 4e13  # â‰ˆ $40T

prep_overlay <- function(df_counts, y_max_counts, cap_val){
  scaler <- make_scaler(min_sec = 0, max_sec = cap_val, min_prim = 0, max_prim = y_max_counts)
  ov <- df_counts %>%
    distinct(country, spend_cum_ppp) %>%
    mutate(
      spend_plot = cap_spend(spend_cum_ppp, cap_val),
      y_overlay  = scaler$fwd(spend_plot),
      overflow   = is.finite(spend_cum_ppp) & spend_cum_ppp > cap_val
    )
  list(overlay = ov, scaler = scaler)
}

# Y-Max fÃ¼r Counts (Panel 1 & 2)
ymax_p1 <- p1_df %>% group_by(country) %>% summarise(T = sum(n), .groups="drop") %>% summarise(max(T, na.rm=TRUE)) %>% pull()
if (!is.finite(ymax_p1) || ymax_p1 <= 0) ymax_p1 <- 1
ymax_p2 <- p2_df %>% group_by(country) %>% summarise(T = sum(n), .groups="drop") %>% summarise(max(T, na.rm=TRUE)) %>% pull()
if (!is.finite(ymax_p2) || ymax_p2 <= 0) ymax_p2 <- 1

ov1 <- prep_overlay(p1_df, ymax_p1, cap_display_ppp)
ov2 <- prep_overlay(p2_df, ymax_p2, cap_display_ppp)

# LÃ¤nder-Order (absteigend nach total counts)
country_order <- p1_df %>%
  group_by(country) %>% summarise(T = sum(n), .groups="drop") %>%
  arrange(desc(T)) %>% pull(country)

p1_df <- p1_df %>% mutate(country = factor(country, levels = country_order))
p2_df <- p2_df %>% mutate(country = factor(country, levels = country_order))
ov1$overlay <- ov1$overlay %>% mutate(country = factor(country, levels = country_order))
ov2$overlay <- ov2$overlay %>% mutate(country = factor(country, levels = country_order))

# (3) Overflow-Labels/ -Pfeile NUR fÃ¼r diese LÃ¤nder (France explizit nicht)
hi_labels <- c("United States","Germany")

add_plot_styling <- function() {
  ggplot2::theme(
    plot.title    = element_text(face = "bold", size = 12, margin = margin(b = 4)),
    plot.subtitle = element_text(size = 9, color = "grey20", margin = margin(b = 6)),
    plot.caption  = element_text(size = 6, margin = margin(t = 4))
  )
}

# -------- Panel 1: Consumer vs Non-Consumer ----------
p1 <- ggplot() +
  geom_col(data = p1_df,
           aes(country, n, fill = target),
           width = BAR_W, color = "white", linewidth = 0.2, position = "stack") +
  # adjacent spending bar (mit Legende)
  geom_col(data = ov1$overlay,
           aes(x = as.numeric(country) + EM_SHIFT, y = y_overlay, fill = spending_legend_label),
           width = EM_W, alpha = 0.95, inherit.aes = FALSE) +
  # overflow marker (nur fÃ¼r hi_labels â†’ kein Pfeil fÃ¼r France)
  geom_segment(data = ov1$overlay %>% filter(overflow, country %in% hi_labels),
               aes(x = as.numeric(country) + EM_SHIFT,
                   xend = as.numeric(country) + EM_SHIFT,
                   y = ov1$scaler$fwd(cap_display_ppp),
                   yend = ov1$scaler$fwd(cap_display_ppp) + 0.06*ymax_p1),
               arrow = arrow(length = grid::unit(3, "pt")),
               linewidth = 0.4, inherit.aes = FALSE) +
  # Labels nur fÃ¼r hi_labels
  geom_text(data = ov1$overlay %>% filter(overflow, country %in% hi_labels),
            aes(x = as.numeric(country) + EM_SHIFT,
                y = ov1$scaler$fwd(cap_display_ppp) + 0.08*ymax_p1,
                label = paste0(as.character(country), ": ",
                               label_dollar(scale_cut = cut_short_scale())(spend_cum_ppp))),
            size = 3, fontface = "bold", inherit.aes = FALSE) +
  scale_fill_manual(
    values = c(col_CN, setNames(emiss_spend_col, spending_legend_label)),
    breaks = c("Consumer", "Non-Consumer", spending_legend_label),
    name = NULL
  ) +
  scale_y_continuous(
    limits = c(0, ymax_p1*1.12),
    labels = comma,
    sec.axis = sec_axis(~ ov1$scaler$inv(.),
                        name = "Cumulative subsidy spending (PPP, constant USD; axis truncated at â‰ˆ$40T",
                        labels = label_dollar(prefix = "$", accuracy = 1,
                                              scale_cut = cut_short_scale()))
  ) +
  scale_x_discrete(expand = expansion(add = OUTER_GAP)) +
  labs(
    title = "Cumulative Subsidy Adoptions (1990â€“2022) â€” Consumer vs Non-Consumer",
    y = "Cumulative counts", x = NULL,
    caption = "Order (Lâˆ’>R): descending total subsidy counts. Cumulative subsidy spending in trillion US Dollar."
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    # kleinere SekundÃ¤achsen-Beschriftung:
    axis.title.y.right = element_text(size = 8),
    axis.text.y.right  = element_text(size = 8),
    # mehr rechter Rand gegen Abschneiden
    plot.margin = margin(5.5, 36, 5.5, 5.5)
  ) +
  coord_cartesian(clip = "off") + 
  add_plot_styling()

# -------- Panel 2: Progressive (inkl. Targeted) vs Regressive ----------
p2 <- ggplot() +
  geom_col(data = p2_df,
           aes(country, n, fill = dist2),
           width = BAR_W, color = "white", linewidth = 0.2, position = "stack") +
  geom_col(data = ov2$overlay,
           aes(x = as.numeric(country) + EM_SHIFT, y = y_overlay, fill = spending_legend_label),
           width = EM_W, alpha = 0.95, inherit.aes = FALSE) +
  # overflow marker (nur fÃ¼r hi_labels â†’ kein Pfeil fÃ¼r France)
  geom_segment(data = ov2$overlay %>% filter(overflow, country %in% hi_labels),
               aes(x = as.numeric(country) + EM_SHIFT,
                   xend = as.numeric(country) + EM_SHIFT,
                   y = ov2$scaler$fwd(cap_display_ppp),
                   yend = ov2$scaler$fwd(cap_display_ppp) + 0.06*ymax_p2),
               arrow = arrow(length = grid::unit(3, "pt")),
               linewidth = 0.4, inherit.aes = FALSE) +
  geom_text(data = ov2$overlay %>% filter(overflow, country %in% hi_labels),
            aes(x = as.numeric(country) + EM_SHIFT,
                y = ov2$scaler$fwd(cap_display_ppp) + 0.085*ymax_p2,
                label = paste0(as.character(country), ": ",
                               label_dollar(scale_cut = cut_short_scale())(spend_cum_ppp))),
            size = 3, fontface = "bold", inherit.aes = FALSE) +
  scale_fill_manual(
    values = c(col_DIST, setNames(emiss_spend_col, spending_legend_label)),
    breaks = c("Progressive", "Regressive", spending_legend_label),
    name = NULL
  ) +
  scale_y_continuous(
    limits = c(0, ymax_p2*1.12),
    labels = comma,
    sec.axis = sec_axis(~ ov2$scaler$inv(.),
                        name = "Cumulative subsidy spending (PPP, constant USD; axis truncated at â‰ˆ$40T",
                        labels = label_dollar(prefix = "$", accuracy = 1,
                                              scale_cut = cut_short_scale()))
  ) +
  scale_x_discrete(expand = expansion(add = OUTER_GAP)) +
  labs(
    title = "Cumulative Consumer Subsidies (1990â€“2022) â€” Progressive vs Regressive",
    y = "Cumulative counts", x = NULL,
    caption = "Order (Lâˆ’>R): descending total consumerâˆ’subsidy counts. Cumulative subsidy spending in trillion US Dollar."
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "top",
    panel.grid.major.x = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    # kleinere SekundÃ¤achsen-Beschriftung:
    axis.title.y.right = element_text(size = 8),
    axis.text.y.right  = element_text(size = 8),
    plot.margin = margin(5.5, 36, 5.5, 5.5)
  ) +
  coord_cartesian(clip = "off") + 
  add_plot_styling()

# -------- Save A4 PDF (two panels vertically) ----------
fig <- (p1 / p2) + plot_layout(heights = c(1,1), guides = "keep") &
  theme(legend.position = "top", legend.justification = "center")

ggsave(file.path(SAVE_DIR, "A4_cumulative_counts_vs_spending_TWO_PANELS.pdf"),
       fig, width = A4W, height = A4H, units = "in")

# -------- Exports: CSV + TeX (interpretable) ----------
export_tbl <- function(df, fname_base, caption, digits = 3){
  write_csv(df, file.path(SAVE_DIR, paste0(fname_base, ".csv")))
  tex <- knitr::kable(df, "latex", booktabs = TRUE, digits = digits,
                      caption = caption, linesep = "") |>
    kableExtra::kable_styling(latex_options = c("hold_position","scale_down"))
  cat(tex, file = file.path(SAVE_DIR, paste0(fname_base, ".tex")))
}

# Panel 1 table: per-country totals + cumulative PPP spend
p1_out <- p1_df %>%
  select(country, target, n, total) %>%
  distinct() %>%
  pivot_wider(names_from = target, values_from = n, values_fill = 0) %>%
  left_join(spend_ok, by = "country") %>%
  arrange(desc(total))

export_tbl(p1_out, "cum_counts_CN_vs_spending",
           "Cumulative subsidy counts (Consumer vs Non-Consumer) and cumulative PPP spending (1990â€“2022; axis cap â‰ˆ$40T).")

# Panel 2 table: per-country totals + cumulative PPP spend
p2_out <- p2_df %>%
  select(country, dist2, n) %>%
  distinct() %>%
  pivot_wider(names_from = dist2, values_from = n, values_fill = 0) %>%
  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE)) %>%
  left_join(spend_ok, by = "country") %>%
  arrange(desc(Total))

export_tbl(p2_out, "cum_counts_DIST_vs_spending",
           "Cumulative consumer subsidy counts by distribution (Progressive incl. Targeted vs Regressive) and cumulative PPP spending (1990â€“2022; axis cap â‰ˆ$40T).")

message("Saved:",
        "\n- A4_cumulative_counts_vs_spending_TWO_PANELS.pdf",
        "\n- cum_counts_CN_vs_spending.{csv,tex}",
        "\n- cum_counts_DIST_vs_spending.{csv,tex}")
```


# 3.1 Greenhouse Gas Emissions Erfolgreiche Instrument Design Emissionspfade
### Aufbereitung/ Data Preparation Pipeline for Emission Indicators and Climate Policy Mix Metrics
```{r}
# =========================================================
# MASTER PREP â€” Emissionen + Policy-Mix (MA3) + Panel + Scores
# Integriert explizit:
#   - PRIMAP CSV EINLESEN (konkreter Pfad), Filter, Longâ†’Wide
#   - ISO3-Subset (deine 23 LÃ¤nder), Missing-Check, Kontroll-Head
#   - Export emiss_df.csv
# Baut anschlieÃŸend:
#   - emiss_idx (log_ghg_pc + Index)
#   - mix4 (MA3-Shares + progressive Consumer MA3)
#   - panel_full (Counts + MA3-Shares + Emissions)
#   - score_bins (Median-Split + Dezile)
# Voraussetzungen:
#   - all_policies_std (Policy-Rohdaten)
# Parameter (optional von auÃŸen setzen):
#   START_YEAR, END_YEAR, BASE_YEAR, PRIMAP_CSV
# =========================================================

suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(stringr); library(readr); library(janitor)
  library(WDI); library(countrycode); library(slider)
})

# ---------------------------
# 0) Parameter, LÃ¤nder-Normierung, Guards
# ---------------------------
START_YEAR <- get0("START_YEAR", ifnotfound = 1990)
END_YEAR   <- get0("END_YEAR",   ifnotfound = 2022)
BASE_YEAR  <- get0("BASE_YEAR",  ifnotfound = max(2010, START_YEAR))

# Pfad zur PRIMAP-CSV: nutze deine konkrete Datei als Default
PRIMAP_CSV <- get0(
  "PRIMAP_CSV",
  ifnotfound = file.path(input_dir, "PRIMAP", "Guetschow_et_al_2025-PRIMAP-hist_v2.6.1_final_13-Mar-2025.csv")
)
stopifnot(file.exists(PRIMAP_CSV))

norm_country <- function(x){
  x %>%
    str_replace("^Korea,? Rep\\.?$|^Republic of Korea$|^Korea,? Republic of$|^South Korea$", "Korea") %>%
    str_replace("^United States of America$|^USA$|^US$", "United States") %>%
    str_replace("^UK$|^Great Britain$", "United Kingdom") %>%
    str_replace("^Czechia$", "Czech Republic") %>%
    str_trim()
}

stopifnot("Datensatz 'all_policies_std' fehlt." = exists("all_policies_std"))
all_policies_std <- all_policies_std %>%
  mutate(country = norm_country(country),
         year    = as.integer(year))

countries_ref <- all_policies_std %>%
  transmute(country = norm_country(country)) %>% distinct()

# ---------------------------
# 1) PRIMAP CSV einlesen + filtern + Long + ISO3-Subset + Wide â†’ emiss_df
# ---------------------------
# --- Deine 23 OECD-LÃ¤nder (ISO3) ---
my_iso3 <- c("BEL","KOR","NZL","CHE","FIN","GRC","JPN","NOR","DNK",
             "CAN","IRL","NLD","LUX","SWE","AUT","AUS","ITA","USA",
             "FRA","PRT","ESP","GBR","DEU")

stopifnot("PRIMAP_CSV-Pfad existiert nicht." = file.exists(PRIMAP_CSV))
df <- read_csv(PRIMAP_CSV, show_col_types = FALSE)

# Filter: National Total excl. LULUCF (M.0.EL), HISTCR, GHG/CO2
df_filtered <- df %>%
  filter(`category (IPCC2006_PRIMAP)` == "M.0.EL",
         `scenario (PRIMAP-hist)` == "HISTCR",
         entity %in% c("KYOTOGHG (AR6GWP100)", "CO2"))

# Wide â†’ Long: Jahres-Spalten einsammeln, Jahr >= START_YEAR
df_long <- df_filtered %>%
  pivot_longer(cols = matches("^[0-9]{4}$"),
               names_to = "year", values_to = "emissions") %>%
  mutate(year = as.integer(year)) %>%
  filter(year >= START_YEAR, year <= END_YEAR)

# Subset auf genau deine ISO3-Liste
df_subset <- df_long %>%
  filter(`area (ISO3)` %in% my_iso3)

# Check: fehlende ISO3 aus deiner Liste (gegen gesamten Long-Datensatz)
missing <- setdiff(my_iso3, unique(df_long$`area (ISO3)`))
print("Fehlende LÃ¤nder im Datensatz:"); print(missing)

# Kurzer Blick (wie in deinem Original)
utils::head(df_subset)

# Wide: Emissionsvariablen nebeneinander (+ ISO3â†’LÃ¤ndernamen)
df_wide <- df_subset %>%
  select(`area (ISO3)`, year, entity, emissions) %>%
  pivot_wider(names_from = entity, values_from = emissions) %>%
  rename(
    iso3      = `area (ISO3)`,
    ghg_total = `KYOTOGHG (AR6GWP100)`,
    co2       = CO2
  ) %>%
  arrange(iso3, year) %>%
  mutate(
    country = countrycode(
      iso3, origin = "iso3c", destination = "country.name",
      warn = TRUE,
      custom_match = c("XKX"="Kosovo","EUU"="European Union","WLD"="World")
    ),
    country = norm_country(country)
  ) %>%
  relocate(country, .after = iso3)

# emiss_df bereitstellen + Export wie bei dir
emiss_df <- df_wide %>%
  select(country, year, ghg_total, co2)
readr::write_csv(emiss_df %>% arrange(iso3 = countrycode(country, "country.name", "iso3c")), "emiss_df.csv")

# ---------------------------
# 2) WDI: BevÃ¶lkerung & reales BIP (fÃ¼r per-capita & IntensitÃ¤t)
# ---------------------------
wdi_raw <- WDI(
  country   = "all",
  indicator = c("SP.POP.TOTL", "NY.GDP.MKTP.KD"),
  start = START_YEAR, end = END_YEAR,
  extra = TRUE, cache = NULL
) %>% clean_names()

wdi_filtered <- wdi_raw %>%
  transmute(
    country = norm_country(country),
    iso3    = iso3c,
    region  = region,
    year    = year,
    population   = sp_pop_totl,
    gdp_constant = ny_gdp_mktp_kd
  ) %>%
  filter(!is.na(region), region != "Aggregates") %>%
  semi_join(countries_ref, by = "country")

# ---------------------------
# 3) Emissionen + WDI mergen â†’ log_ghg_pc & emiss_idx
# ---------------------------
emiss_prepped <- emiss_df %>%
  mutate(country = norm_country(country)) %>%
  left_join(wdi_filtered %>% select(country, year, population),   by = c("country","year")) %>%
  left_join(wdi_filtered %>% select(country, year, gdp_constant), by = c("country","year")) %>%
  filter(between(year, START_YEAR, END_YEAR)) %>%
  mutate(
    ghg_pc     = if_else(is.finite(ghg_total) & is.finite(population) & population > 0,
                         ghg_total / population, NA_real_),
    log_ghg_pc = log(ghg_pc)
  ) %>%
  arrange(country, year)

# robuster Index auf BASE_YEAR (oder erstes Jahr â‰¥ BASE_YEAR)
emiss_idx <- emiss_prepped %>%
  group_by(country) %>%
  mutate(
    base_y  = if (BASE_YEAR %in% year) BASE_YEAR else suppressWarnings(min(year[year >= BASE_YEAR], na.rm = TRUE)),
    base_lp = log_ghg_pc[match(base_y, year)],
    em_idx  = 100 * exp(log_ghg_pc - base_lp)
  ) %>%
  ungroup() %>%
  select(country, year, em_idx, log_ghg_pc)

# ---------------------------
# 4) Policy-Mix: Segment-Counts â†’ Anteile (MA3) + Distributiv (Consumer)
# ---------------------------
# 4.1 Jahres-Counts
seg_counts <- all_policies_std %>%
  count(country, year, dataset, target, name = "n")

# 4.2 Shares + MA3
seg_share <- seg_counts %>%
  tidyr::pivot_wider(names_from = c(dataset, target), values_from = n, values_fill = 0) %>%
  transmute(
    country, year,
    n_SC = `Subsidy_Consumer`,
    n_SN = `Subsidy_Non-Consumer`,
    n_RC = `Regulation_Consumer`,
    n_RN = `Regulation_Non-Consumer`,
    n_total = n_SC + n_SN + n_RC + n_RN,
    s_SC = if_else(n_total > 0, n_SC/n_total, NA_real_),
    s_SN = if_else(n_total > 0, n_SN/n_total, NA_real_),
    s_RC = if_else(n_total > 0, n_RC/n_total, NA_real_),
    s_RN = if_else(n_total > 0, n_RN/n_total, NA_real_)
  ) %>%
  arrange(country, year) %>%
  group_by(country) %>%
  mutate(across(c(s_SC, s_SN, s_RC, s_RN),
                ~ slide_dbl(.x, mean, .before = 2, na.rm = TRUE),
                .names = "{.col}_MA3")) %>%
  ungroup() %>%
  select(country, year, ends_with("_MA3"))

# 4.3 Distributive Klassifizierung (Consumer) + MA3
pol_dist <- all_policies_std %>%
  mutate(
    dist_raw = dplyr::case_when(
      target == "Consumer" & dataset == "Subsidy"    ~ as.character(income_group),
      target == "Consumer" & dataset == "Regulation" ~ as.character(income_burden_group),
      TRUE ~ NA_character_
    ) %>% trimws(),
    dist2 = dplyr::case_when(
      target == "Consumer" & dataset == "Subsidy"    & dist_raw == "Higher income"                            ~ "Regressive",
      target == "Consumer" & dataset == "Subsidy"    & dist_raw %in% c("Lower income","All incomes equally")  ~ "Progressive",
      target == "Consumer" & dataset == "Regulation" & dist_raw == "Lower income"                             ~ "Regressive",
      target == "Consumer" & dataset == "Regulation" & dist_raw %in% c("All incomes equally","Higher income") ~ "Progressive",
      TRUE ~ NA_character_
    )
  )

dist2_year <- pol_dist %>%
  filter(target == "Consumer", !is.na(dist2)) %>%
  count(country, year, dist2, name = "n") %>%
  pivot_wider(names_from = dist2, values_from = n, values_fill = 0) %>%
  mutate(
    total = dplyr::coalesce(Progressive,0L) + dplyr::coalesce(Regressive,0L),
    prog_share_cons = if_else(total > 0, Progressive/total, NA_real_)
  ) %>%
  arrange(country, year) %>%
  group_by(country) %>%
  mutate(prog_share_cons_MA3 = slide_dbl(prog_share_cons, mean, .before = 2, na.rm = TRUE)) %>%
  ungroup() %>%
  select(country, year, prog_share_cons_MA3)

# 4.4 mix4 = MA3-Shares + progressive Consumer (MA3)
mix4 <- seg_share %>%
  left_join(dist2_year, by = c("country","year"))

# ---------------------------
# 5) panel_full: Emissions + (re)Counts + MA3-Shares
# ---------------------------
counts_year <- seg_counts %>%
  tidyr::pivot_wider(names_from = c(dataset, target), values_from = n, values_fill = 0) %>%
  transmute(
    country, year,
    n_SC = `Subsidy_Consumer`,
    n_SN = `Subsidy_Non-Consumer`,
    n_RC = `Regulation_Consumer`,
    n_RN = `Regulation_Non-Consumer`,
    n_total = n_SC + n_SN + n_RC + n_RN,
    n_cons  = n_SC + n_RC,
    n_nonco = n_SN + n_RN
  )

dist_counts_year <- pol_dist %>%
  filter(target == "Consumer", !is.na(dist2)) %>%
  count(country, year, dist2, name = "n") %>%
  tidyr::pivot_wider(names_from = dist2, values_from = n, values_fill = 0) %>%
  transmute(country, year,
            n_prog_cons = dplyr::coalesce(Progressive, 0L),
            n_regr_cons = dplyr::coalesce(Regressive, 0L))

panel_full <- mix4 %>%
  left_join(emiss_idx %>% select(country, year, em_idx, log_ghg_pc), by = c("country","year")) %>%
  left_join(counts_year,      by = c("country","year")) %>%
  left_join(dist_counts_year, by = c("country","year")) %>%
  filter(year >= START_YEAR, year <= END_YEAR)

# Sammel-Shares (MA3) sicherstellen
safe_sum2 <- function(a, b) ifelse(is.na(a) & is.na(b), NA_real_, dplyr::coalesce(a, 0) + dplyr::coalesce(b, 0))
if (!("s_cons_MA3"  %in% names(panel_full)))  panel_full <- mutate(panel_full,  s_cons_MA3  = safe_sum2(s_SC_MA3, s_RC_MA3))
if (!("s_nonco_MA3" %in% names(panel_full))) panel_full <- mutate(panel_full, s_nonco_MA3 = safe_sum2(s_SN_MA3, s_RN_MA3))

# ---------------------------
# 6) Emissions-Scores â†’ Median-Split & Dezile (score_bins)
# ---------------------------
build_scores_safe <- function(em_df, base_year, end_year, strict_end = FALSE){
  em_df %>%
    filter(is.finite(log_ghg_pc)) %>%
    arrange(country, year) %>%
    group_by(country) %>%
    reframe({
      yy <- year; lg <- log_ghg_pc
      base_y <- if (base_year %in% yy) base_year else suppressWarnings(min(yy[yy >= base_year], na.rm = TRUE))
      has_base <- is.finite(base_y) && any(yy == base_y)
      end_y <- if (strict_end) end_year else suppressWarnings(max(yy[yy <= end_year], na.rm = TRUE))
      has_end <- is.finite(end_y) && any(yy == end_y)
      ld12 <- if (has_base && has_end) lg[match(end_y, yy)] - lg[match(base_y, yy)] else NA_real_
      slope <- if (has_base) {
        idx <- which(yy >= base_y & is.finite(lg))
        if (length(idx) >= 2) unname(coef(lm(lg[idx] ~ yy[idx]))[2]) else NA_real_
      } else NA_real_
      tibble(ld12 = ld12, slope_1018xx = slope)
    }) %>%
    ungroup() %>%
    mutate(score = -0.5*ld12 - 0.5*slope_1018xx)
}

scores_new <- build_scores_safe(
  panel_full %>% select(country, year, log_ghg_pc),
  BASE_YEAR, END_YEAR, strict_end = FALSE
)

score_bins <- scores_new %>%
  transmute(
    country = norm_country(country),
    score,
    success_bin_med = if_else(score <= median(score, na.rm = TRUE), "Low", "High"),
    decile = dplyr::ntile(score, 10)
  )

panel_full <- panel_full %>% left_join(score_bins, by = "country")

# ---------------------------
# 7) Checks & Meldungen
# ---------------------------
need_pf <- c("country","year","s_SC_MA3","s_SN_MA3","s_RC_MA3","s_RN_MA3",
             "n_SC","n_SN","n_RC","n_RN","n_cons","n_nonco","em_idx","log_ghg_pc",
             "n_prog_cons","n_regr_cons","success_bin_med","decile")
stopifnot("panel_full: erwartete Spalten fehlen." = all(need_pf %in% names(panel_full)))

need_em <- c("country","year","em_idx","log_ghg_pc")
stopifnot("emiss_idx fehlt Pflichtspalten." = all(need_em %in% names(emiss_idx)))

need_mx <- c("country","year","s_SC_MA3","s_SN_MA3","s_RC_MA3","s_RN_MA3","prog_share_cons_MA3")
stopifnot("mix4 unvollstÃ¤ndig." = all(need_mx %in% names(mix4)))

message(sprintf("âœ“ PREP fertig: %d LÃ¤nder in policies, %d LÃ¤nder in emiss_idx.",
                dplyr::n_distinct(all_policies_std$country), dplyr::n_distinct(emiss_idx$country)))
message(sprintf("  panel_full: %d Reihen; mix4: %d Reihen.",
                nrow(panel_full), nrow(mix4)))
```

### Aufbereitung/ Data Preparation Pipeline for Emission Indicators and Climate Policy Mix Metrics
```{r}
# =========================================================
# MASTER PREP â€” Emissionen + Policy-Mix (MA3) + Panel + Scores
# Integriert explizit:
#   - PRIMAP CSV EINLESEN (konkreter Pfad), Filter, Longâ†’Wide
#   - ISO3-Subset (deine 23 LÃ¤nder), Missing-Check, Kontroll-Head
#   - Export emiss_df.csv
# Baut anschlieÃŸend:
#   - emiss_idx (log_ghg_pc + Index)
#   - mix4 (MA3-Shares + progressive Consumer MA3)
#   - panel_full (Counts + MA3-Shares + Emissions)
#   - score_bins (Median-Split + Dezile)
# Voraussetzungen:
#   - all_policies_std (Policy-Rohdaten)
# Parameter (optional von auÃŸen setzen):
#   START_YEAR, END_YEAR, BASE_YEAR, PRIMAP_CSV
# =========================================================

suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(stringr); library(readr); library(janitor)
  library(WDI); library(countrycode); library(slider)
})

# ---------------------------
# 0) Parameter, LÃ¤nder-Normierung, Guards
# ---------------------------
START_YEAR <- get0("START_YEAR", ifnotfound = 1990)
END_YEAR   <- get0("END_YEAR",   ifnotfound = 2022)
BASE_YEAR  <- get0("BASE_YEAR",  ifnotfound = max(2010, START_YEAR))

# Pfad zur PRIMAP-CSV: nutze deine konkrete Datei als Default
PRIMAP_CSV <- get0(
  "PRIMAP_CSV",
  ifnotfound = file.path(input_dir, "PRIMAP", "Guetschow_et_al_2025-PRIMAP-hist_v2.6.1_final_13-Mar-2025.csv")
)
stopifnot(file.exists(PRIMAP_CSV))

norm_country <- function(x){
  x %>%
    str_replace("^Korea,? Rep\\.?$|^Republic of Korea$|^Korea,? Republic of$|^South Korea$", "Korea") %>%
    str_replace("^United States of America$|^USA$|^US$", "United States") %>%
    str_replace("^UK$|^Great Britain$", "United Kingdom") %>%
    str_replace("^Czechia$", "Czech Republic") %>%
    str_trim()
}

stopifnot("Datensatz 'all_policies_std' fehlt." = exists("all_policies_std"))
all_policies_std <- all_policies_std %>%
  mutate(country = norm_country(country),
         year    = as.integer(year))

countries_ref <- all_policies_std %>%
  transmute(country = norm_country(country)) %>% distinct()

# ---------------------------
# 1) PRIMAP CSV einlesen + filtern + Long + ISO3-Subset + Wide â†’ emiss_df
# ---------------------------
# --- Deine 23 OECD-LÃ¤nder (ISO3) ---
my_iso3 <- c("BEL","KOR","NZL","CHE","FIN","GRC","JPN","NOR","DNK",
             "CAN","IRL","NLD","LUX","SWE","AUT","AUS","ITA","USA",
             "FRA","PRT","ESP","GBR","DEU")

stopifnot("PRIMAP_CSV-Pfad existiert nicht." = file.exists(PRIMAP_CSV))
df <- read_csv(PRIMAP_CSV, show_col_types = FALSE)

# Filter: National Total excl. LULUCF (M.0.EL), HISTCR, GHG/CO2
df_filtered <- df %>%
  filter(`category (IPCC2006_PRIMAP)` == "M.0.EL",
         `scenario (PRIMAP-hist)` == "HISTCR",
         entity %in% c("KYOTOGHG (AR6GWP100)", "CO2"))

# Wide â†’ Long: Jahres-Spalten einsammeln, Jahr >= START_YEAR
df_long <- df_filtered %>%
  pivot_longer(cols = matches("^[0-9]{4}$"),
               names_to = "year", values_to = "emissions") %>%
  mutate(year = as.integer(year)) %>%
  filter(year >= START_YEAR, year <= END_YEAR)

# Subset auf genau deine ISO3-Liste
df_subset <- df_long %>%
  filter(`area (ISO3)` %in% my_iso3)

# Check: fehlende ISO3 aus deiner Liste (gegen gesamten Long-Datensatz)
missing <- setdiff(my_iso3, unique(df_long$`area (ISO3)`))
print("Fehlende LÃ¤nder im Datensatz:"); print(missing)

# Kurzer Blick (wie in deinem Original)
utils::head(df_subset)

# Wide: Emissionsvariablen nebeneinander (+ ISO3â†’LÃ¤ndernamen)
df_wide <- df_subset %>%
  select(`area (ISO3)`, year, entity, emissions) %>%
  pivot_wider(names_from = entity, values_from = emissions) %>%
  rename(
    iso3      = `area (ISO3)`,
    ghg_total = `KYOTOGHG (AR6GWP100)`,
    co2       = CO2
  ) %>%
  arrange(iso3, year) %>%
  mutate(
    country = countrycode(
      iso3, origin = "iso3c", destination = "country.name",
      warn = TRUE,
      custom_match = c("XKX"="Kosovo","EUU"="European Union","WLD"="World")
    ),
    country = norm_country(country)
  ) %>%
  relocate(country, .after = iso3)

# emiss_df bereitstellen + Export wie bei dir
emiss_df <- df_wide %>%
  select(country, year, ghg_total, co2)
readr::write_csv(emiss_df %>% arrange(iso3 = countrycode(country, "country.name", "iso3c")), "emiss_df.csv")

# ---------------------------
# 2) WDI: BevÃ¶lkerung & reales BIP (fÃ¼r per-capita & IntensitÃ¤t)
# ---------------------------
wdi_raw <- WDI(
  country   = "all",
  indicator = c("SP.POP.TOTL", "NY.GDP.MKTP.KD"),
  start = START_YEAR, end = END_YEAR,
  extra = TRUE, cache = NULL
) %>% clean_names()

wdi_filtered <- wdi_raw %>%
  transmute(
    country = norm_country(country),
    iso3    = iso3c,
    region  = region,
    year    = year,
    population   = sp_pop_totl,
    gdp_constant = ny_gdp_mktp_kd
  ) %>%
  filter(!is.na(region), region != "Aggregates") %>%
  semi_join(countries_ref, by = "country")

# ---------------------------
# 3) Emissionen + WDI mergen â†’ log_ghg_pc & emiss_idx
# ---------------------------
emiss_prepped <- emiss_df %>%
  mutate(country = norm_country(country)) %>%
  left_join(wdi_filtered %>% select(country, year, population),   by = c("country","year")) %>%
  left_join(wdi_filtered %>% select(country, year, gdp_constant), by = c("country","year")) %>%
  filter(between(year, START_YEAR, END_YEAR)) %>%
  mutate(
    ghg_pc     = if_else(is.finite(ghg_total) & is.finite(population) & population > 0,
                         ghg_total / population, NA_real_),
    log_ghg_pc = log(ghg_pc)
  ) %>%
  arrange(country, year)

# robuster Index auf BASE_YEAR (oder erstes Jahr â‰¥ BASE_YEAR)
emiss_idx <- emiss_prepped %>%
  group_by(country) %>%
  mutate(
    base_y  = if (BASE_YEAR %in% year) BASE_YEAR else suppressWarnings(min(year[year >= BASE_YEAR], na.rm = TRUE)),
    base_lp = log_ghg_pc[match(base_y, year)],
    em_idx  = 100 * exp(log_ghg_pc - base_lp)
  ) %>%
  ungroup() %>%
  select(country, year, em_idx, log_ghg_pc)

# ---------------------------
# 4) Policy-Mix: Segment-Counts â†’ Anteile (MA3) + Distributiv (Consumer)
# ---------------------------
# 4.1 Jahres-Counts
seg_counts <- all_policies_std %>%
  count(country, year, dataset, target, name = "n")

# 4.2 Shares + MA3
seg_share <- seg_counts %>%
  tidyr::pivot_wider(names_from = c(dataset, target), values_from = n, values_fill = 0) %>%
  transmute(
    country, year,
    n_SC = `Subsidy_Consumer`,
    n_SN = `Subsidy_Non-Consumer`,
    n_RC = `Regulation_Consumer`,
    n_RN = `Regulation_Non-Consumer`,
    n_total = n_SC + n_SN + n_RC + n_RN,
    s_SC = if_else(n_total > 0, n_SC/n_total, NA_real_),
    s_SN = if_else(n_total > 0, n_SN/n_total, NA_real_),
    s_RC = if_else(n_total > 0, n_RC/n_total, NA_real_),
    s_RN = if_else(n_total > 0, n_RN/n_total, NA_real_)
  ) %>%
  arrange(country, year) %>%
  group_by(country) %>%
  mutate(across(c(s_SC, s_SN, s_RC, s_RN),
                ~ slide_dbl(.x, mean, .before = 2, na.rm = TRUE),
                .names = "{.col}_MA3")) %>%
  ungroup() %>%
  select(country, year, ends_with("_MA3"))

# 4.3 Distributive Klassifizierung (Consumer) + MA3
pol_dist <- all_policies_std %>%
  mutate(
    dist_raw = dplyr::case_when(
      target == "Consumer" & dataset == "Subsidy"    ~ as.character(income_group),
      target == "Consumer" & dataset == "Regulation" ~ as.character(income_burden_group),
      TRUE ~ NA_character_
    ) %>% trimws(),
    dist2 = dplyr::case_when(
      target == "Consumer" & dataset == "Subsidy"    & dist_raw == "Higher income"                            ~ "Regressive",
      target == "Consumer" & dataset == "Subsidy"    & dist_raw %in% c("Lower income","All incomes equally")  ~ "Progressive",
      target == "Consumer" & dataset == "Regulation" & dist_raw == "Lower income"                             ~ "Regressive",
      target == "Consumer" & dataset == "Regulation" & dist_raw %in% c("All incomes equally","Higher income") ~ "Progressive",
      TRUE ~ NA_character_
    )
  )

dist2_year <- pol_dist %>%
  filter(target == "Consumer", !is.na(dist2)) %>%
  count(country, year, dist2, name = "n") %>%
  pivot_wider(names_from = dist2, values_from = n, values_fill = 0) %>%
  mutate(
    total = dplyr::coalesce(Progressive,0L) + dplyr::coalesce(Regressive,0L),
    prog_share_cons = if_else(total > 0, Progressive/total, NA_real_)
  ) %>%
  arrange(country, year) %>%
  group_by(country) %>%
  mutate(prog_share_cons_MA3 = slide_dbl(prog_share_cons, mean, .before = 2, na.rm = TRUE)) %>%
  ungroup() %>%
  select(country, year, prog_share_cons_MA3)

# 4.4 mix4 = MA3-Shares + progressive Consumer (MA3)
mix4 <- seg_share %>%
  left_join(dist2_year, by = c("country","year"))

# ---------------------------
# 5) panel_full: Emissions + (re)Counts + MA3-Shares
# ---------------------------
counts_year <- seg_counts %>%
  tidyr::pivot_wider(names_from = c(dataset, target), values_from = n, values_fill = 0) %>%
  transmute(
    country, year,
    n_SC = `Subsidy_Consumer`,
    n_SN = `Subsidy_Non-Consumer`,
    n_RC = `Regulation_Consumer`,
    n_RN = `Regulation_Non-Consumer`,
    n_total = n_SC + n_SN + n_RC + n_RN,
    n_cons  = n_SC + n_RC,
    n_nonco = n_SN + n_RN
  )

dist_counts_year <- pol_dist %>%
  filter(target == "Consumer", !is.na(dist2)) %>%
  count(country, year, dist2, name = "n") %>%
  tidyr::pivot_wider(names_from = dist2, values_from = n, values_fill = 0) %>%
  transmute(country, year,
            n_prog_cons = dplyr::coalesce(Progressive, 0L),
            n_regr_cons = dplyr::coalesce(Regressive, 0L))

panel_full <- mix4 %>%
  left_join(emiss_idx %>% select(country, year, em_idx, log_ghg_pc), by = c("country","year")) %>%
  left_join(counts_year,      by = c("country","year")) %>%
  left_join(dist_counts_year, by = c("country","year")) %>%
  filter(year >= START_YEAR, year <= END_YEAR)

# Sammel-Shares (MA3) sicherstellen
safe_sum2 <- function(a, b) ifelse(is.na(a) & is.na(b), NA_real_, dplyr::coalesce(a, 0) + dplyr::coalesce(b, 0))
if (!("s_cons_MA3"  %in% names(panel_full)))  panel_full <- mutate(panel_full,  s_cons_MA3  = safe_sum2(s_SC_MA3, s_RC_MA3))
if (!("s_nonco_MA3" %in% names(panel_full))) panel_full <- mutate(panel_full, s_nonco_MA3 = safe_sum2(s_SN_MA3, s_RN_MA3))

# ---------------------------
# 6) Emissions-Scores â†’ Median-Split & Dezile (score_bins)
# ---------------------------
build_scores_safe <- function(em_df, base_year, end_year, strict_end = FALSE){
  em_df %>%
    filter(is.finite(log_ghg_pc)) %>%
    arrange(country, year) %>%
    group_by(country) %>%
    reframe({
      yy <- year; lg <- log_ghg_pc
      base_y <- if (base_year %in% yy) base_year else suppressWarnings(min(yy[yy >= base_year], na.rm = TRUE))
      has_base <- is.finite(base_y) && any(yy == base_y)
      end_y <- if (strict_end) end_year else suppressWarnings(max(yy[yy <= end_year], na.rm = TRUE))
      has_end <- is.finite(end_y) && any(yy == end_y)
      ld12 <- if (has_base && has_end) lg[match(end_y, yy)] - lg[match(base_y, yy)] else NA_real_
      slope <- if (has_base) {
        idx <- which(yy >= base_y & is.finite(lg))
        if (length(idx) >= 2) unname(coef(lm(lg[idx] ~ yy[idx]))[2]) else NA_real_
      } else NA_real_
      tibble(ld12 = ld12, slope_1018xx = slope)
    }) %>%
    ungroup() %>%
    mutate(score = -0.5*ld12 - 0.5*slope_1018xx)
}

scores_new <- build_scores_safe(
  panel_full %>% select(country, year, log_ghg_pc),
  BASE_YEAR, END_YEAR, strict_end = FALSE
)

score_bins <- scores_new %>%
  transmute(
    country = norm_country(country),
    score,
    success_bin_med = if_else(score <= median(score, na.rm = TRUE), "Low", "High"),
    decile = dplyr::ntile(score, 10)
  )

panel_full <- panel_full %>% left_join(score_bins, by = "country")

# ---------------------------
# 7) Checks & Meldungen
# ---------------------------
need_pf <- c("country","year","s_SC_MA3","s_SN_MA3","s_RC_MA3","s_RN_MA3",
             "n_SC","n_SN","n_RC","n_RN","n_cons","n_nonco","em_idx","log_ghg_pc",
             "n_prog_cons","n_regr_cons","success_bin_med","decile")
stopifnot("panel_full: erwartete Spalten fehlen." = all(need_pf %in% names(panel_full)))

need_em <- c("country","year","em_idx","log_ghg_pc")
stopifnot("emiss_idx fehlt Pflichtspalten." = all(need_em %in% names(emiss_idx)))

need_mx <- c("country","year","s_SC_MA3","s_SN_MA3","s_RC_MA3","s_RN_MA3","prog_share_cons_MA3")
stopifnot("mix4 unvollstÃ¤ndig." = all(need_mx %in% names(mix4)))

message(sprintf("âœ“ PREP fertig: %d LÃ¤nder in policies, %d LÃ¤nder in emiss_idx.",
                dplyr::n_distinct(all_policies_std$country), dplyr::n_distinct(emiss_idx$country)))
message(sprintf("  panel_full: %d Reihen; mix4: %d Reihen.",
                nrow(panel_full), nrow(mix4)))
```

### Ausgabe neu: Time-collapsed policy mix profiles after emissions decline (median split + 95% CIs (3 Facets)) # Bottom: Extremes p10/p90 3Ã—100% Stacks (3 Facets) 
```{r}
# =========================================================
# ONE-STOP: High vs Low Profiles (A4 portrait, 2 Panels)
# Top  : Median-split (High/Low) with 95% CIs â€” 3 facets
# Bottom: Extremes p10/p90 â€” 3Ã—100% stacks
# + Exports tidy, interpretable CSVs used for both panels
# Requirements in workspace:
#   - panel_full  (has s_SC_MA3, s_SN_MA3, s_RC_MA3, s_RN_MA3, prog_share_cons_MA3)
#   - scores_new  (country, score)
# Outputs (in SAVE_DIR):
#   - A4_HvsL_DOUBLE.pdf
#   - HvsL_mediansplit_CIs_long.csv, HvsL_mediansplit_CIs_wide.csv
#   - HvsL_mediansplit_bin_sizes.csv
#   - HvsL_bootstrap_diffs.csv
#   - EXTREMES_10_90_table.csv, EXTREMES_10_90_members.csv
# =========================================================

suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(ggplot2); library(forcats)
  library(readr); library(scales); library(patchwork); library(purrr)
})

# ---------- Guards ----------
stopifnot("panel_full missing" = exists("panel_full"))
stopifnot("scores_new missing" = exists("scores_new"))

# ---------- Settings ----------
SAVE_DIR <- getOption("mix_save_dir", default = ".")
dir.create(SAVE_DIR, recursive = TRUE, showWarnings = FALSE)

# Colors
consumer_blue     <- "#4C9BE8"
nonconsumer_blue  <- "#1E6BB8"
reg_consumer_red  <- "#F08080"
reg_noncons_red   <- "#C0392B"
fill_map <- c(
  "Fiscal Support" = consumer_blue, "Regulation"    = reg_noncons_red,
  "Consumer"       = consumer_blue, "Non-Consumer"  = nonconsumer_blue,
  "Regressive"     = reg_noncons_red, "Progressive" = consumer_blue
)

# ---------- Time-collapsed country values ----------
mix_country <- panel_full %>%
  group_by(country) %>%
  summarise(
    s_SC = mean(s_SC_MA3, na.rm = TRUE),
    s_SN = mean(s_SN_MA3, na.rm = TRUE),
    s_RC = mean(s_RC_MA3, na.rm = TRUE),
    s_RN = mean(s_RN_MA3, na.rm = TRUE),
    prog_cons = mean(prog_share_cons_MA3, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    s_sub   = pmin(pmax(s_SC + s_SN, 0), 1),
    s_reg   = pmin(pmax(s_RC + s_RN, 0), 1),
    s_cons  = pmin(pmax(s_SC + s_RC, 0), 1),
    s_nonco = pmin(pmax(s_SN + s_RN, 0), 1),
    regr_cons = dplyr::if_else(is.finite(prog_cons), 1 - prog_cons, NA_real_)
  ) %>%
  left_join(scores_new %>% select(country, score), by = "country") %>%
  filter(is.finite(score))

# =========================================================
# TOP PANEL â€” Median-split (High/Low) with 95% CIs
# =========================================================
# Build bins (median split)
score_bins <- scores_new %>%
  transmute(country, score,
            success_bin_med = if_else(score <= median(score, na.rm = TRUE), "Low", "High"))

# Country x Bin table with metrics
tc_country <- mix_country %>%
  left_join(score_bins, by = "country") %>%
  filter(!is.na(success_bin_med)) %>%
  select(country, success_bin_med, s_sub, s_reg, s_cons, s_nonco, prog_cons, regr_cons)

# Bootstrap CI helper
BOOT_B <- get0("BOOT_B", ifnotfound = 5000)
BOOT_SEED <- get0("BOOT_SEED", ifnotfound = 123)
ci_boot <- function(v, B = BOOT_B, seed = BOOT_SEED){
  v <- v[is.finite(v)]
  n <- length(v)
  if (n <= 2) {
    m <- mean(v); se <- sd(v)/sqrt(max(n,1))
    return(tibble(mean = m, n = n, se = se,
                  lwr = m - 1.96*se, upr = m + 1.96*se))
  }
  set.seed(seed)
  boot <- replicate(B, mean(sample(v, replace = TRUE)))
  tibble(
    mean = mean(v), n = n, se = sd(boot),
    lwr = as.numeric(quantile(boot, 0.025, type = 6)),
    upr = as.numeric(quantile(boot, 0.975, type = 6))
  )
}

# CI table (long)
tc_country_long <- tc_country %>%
  pivot_longer(-c(country, success_bin_med), names_to = "metric", values_to = "val")

tc_bin_ci <- tc_country_long %>%
  group_by(success_bin_med, metric) %>%
  summarise(ci_boot(val), .groups = "drop")

# Human-readable labels + facet tags
top_ci_plot_df <- bind_rows(
  tc_bin_ci %>% filter(metric %in% c("s_sub","s_reg")) %>%
    mutate(panel = "Instrument",
           lab = recode(metric, s_sub = "Fiscal Support", s_reg = "Regulation")),
  tc_bin_ci %>% filter(metric %in% c("s_cons","s_nonco")) %>%
    mutate(panel = "Targeting",
           lab = recode(metric, s_cons = "Consumer", s_nonco = "Non-Consumer")),
  tc_bin_ci %>% filter(metric %in% c("prog_cons","regr_cons")) %>%
    mutate(panel = "Distribution (consumer)",
           lab = recode(metric, prog_cons = "Progressive", regr_cons = "Regressive"))
) %>%
  mutate(
    success_bin_med = factor(success_bin_med, levels = c("Low","High"),
                             labels = c("Low (weaker)", "High (stronger)")),
    panel = factor(panel, levels = c("Instrument","Targeting","Distribution (consumer)")),
    lab   = factor(lab,   levels = c("Fiscal Support","Regulation","Consumer","Non-Consumer","Progressive","Regressive"))
  )

# Plot (Top)
p_top <- ggplot(top_ci_plot_df, aes(success_bin_med, mean, fill = lab)) +
  geom_col(position = position_dodge(width = 0.72), width = 0.72) +
  geom_errorbar(aes(ymin = lwr, ymax = upr),
                position = position_dodge(width = 0.72), width = 0.22) +
  facet_wrap(~ panel, nrow = 1) +
  scale_y_continuous(limits = c(0,1), labels = percent_format(accuracy = 1)) +
  scale_fill_manual(values = fill_map, name = NULL) +
  labs(
    title = "High vs Low (Median split): time-collapsed shares with 95% CIs",
    x = NULL, y = "Share (0â€“1)"
  ) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "top", panel.grid.major.x = element_blank(),
        strip.text = element_text(face = "bold"))

# Exports (Top)
# Long CI table with labels
write_csv(
  top_ci_plot_df %>%
    select(panel, success_bin_med, lab, mean, lwr, upr, n, se) %>%
    arrange(panel, lab, success_bin_med),
  file.path(SAVE_DIR, "HvsL_mediansplit_CIs_long.csv")
)
# Wide CI table (per panel x lab; columns Low/High means + CIs)
top_ci_wide <- top_ci_plot_df %>%
  select(panel, lab, success_bin_med, mean, lwr, upr) %>%
  pivot_longer(cols = c(mean,lwr,upr), names_to = "stat", values_to = "value") %>%
  unite(col = "bin_stat", success_bin_med, stat, sep = "_") %>%
  pivot_wider(names_from = bin_stat, values_from = value) %>%
  arrange(panel, lab)
write_csv(top_ci_wide, file.path(SAVE_DIR, "HvsL_mediansplit_CIs_wide.csv"))

# Bin sizes
bin_sizes <- tc_country %>% count(success_bin_med, name = "n_countries") %>%
  mutate(success_bin_med = factor(success_bin_med, levels = c("Low","High"),
                                  labels = c("Low (weaker)","High (stronger)")))
write_csv(bin_sizes, file.path(SAVE_DIR, "HvsL_mediansplit_bin_sizes.csv"))

# Bootstrap Highâˆ’Low differences (sign & magnitude)
boot_diff_HL <- function(df, metric, group = "success_bin_med", B = BOOT_B, seed = BOOT_SEED){
  stopifnot(all(c(metric, group) %in% names(df)))
  xH <- df %>% filter(.data[[group]] == "High") %>% pull(!!metric) %>% .[is.finite(.)]
  xL <- df %>% filter(.data[[group]] == "Low")  %>% pull(!!metric) %>% .[is.finite(.)]
  nH <- length(xH); nL <- length(xL)
  if (nH == 0 || nL == 0) return(tibble(metric, nH, nL, diff = NA_real_, se = NA_real_, lwr = NA_real_, upr = NA_real_, p_boot = NA_real_))
  diff_emp <- mean(xH) - mean(xL)
  set.seed(seed)
  boot <- replicate(B, mean(sample(xH, replace = TRUE)) - mean(sample(xL, replace = TRUE)))
  qs <- quantile(boot, c(0.025, 0.975), type = 6, na.rm = TRUE)
  se <- sd(boot)
  p  <- 2 * min(mean(boot <= 0, na.rm = TRUE), mean(boot >= 0, na.rm = TRUE))
  tibble(metric, nH, nL, diff = diff_emp, se = se, lwr = as.numeric(qs[1]), upr = as.numeric(qs[2]), p_boot = p)
}
metrics_to_test <- c("s_sub","s_reg","s_cons","s_nonco","prog_cons","regr_cons")
boot_HL_results <- map_dfr(metrics_to_test, ~ boot_diff_HL(tc_country, .x)) %>%
  mutate(metric = recode(metric,
                         s_sub="Fiscal Support share", s_reg="Regulation share",
                         s_cons="Consumer share",     s_nonco="Non-consumer share",
                         prog_cons="Progressive (consumer)", regr_cons="Regressive (consumer)")) %>%
  arrange(metric)
write_csv(boot_HL_results, file.path(SAVE_DIR, "HvsL_bootstrap_diffs.csv"))

# =========================================================
# BOTTOM PANEL â€” Extremes p10/p90 (3Ã—100% stacks)
# =========================================================
# Build Top/Bottom (p90/p10)
qs <- quantile(mix_country$score, c(0.10, 0.90), na.rm = TRUE, names = FALSE)
ext_lab <- mix_country %>%
  mutate(group = case_when(
    score <= qs[1] ~ "Bottom (weaker)",
    score >= qs[2] ~ "Top (stronger)",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(group)) %>%
  mutate(group = factor(group, levels = c("Bottom (weaker)","Top (stronger)")))

# Summaries for stacks (means per group)
tab_ext <- ext_lab %>%
  group_by(group) %>%
  summarise(
    `Fiscal Support (share of all policies)`   = mean(s_sub,   na.rm = TRUE),
    `Regulation (share of all policies)`       = mean(s_reg,   na.rm = TRUE),
    `Consumer (share of all policies)`         = mean(s_cons,  na.rm = TRUE),
    `Non-Consumer (share of all policies)`     = mean(s_nonco, na.rm = TRUE),
    `Progressive (share of consumer policies)` = mean(prog_cons, na.rm = TRUE),
    `Regressive (share of consumer policies)`  = mean(regr_cons, na.rm = TRUE),
    n_countries = dplyr::n(),
    .groups = "drop"
  )

# Readable comparison table (Bottom/Top/Diff)
ext_wide <- tab_ext %>%
  pivot_longer(-c(group, n_countries), names_to = "component", values_to = "value") %>%
  select(-n_countries) %>%
  pivot_wider(names_from = group, values_from = value) %>%
  mutate(Difference = `Top (stronger)` - `Bottom (weaker)`) %>%
  arrange(component)
write_csv(ext_wide, file.path(SAVE_DIR, "EXTREMES_10_90_table.csv"))

# Members (transparency)
write_csv(
  ext_lab %>% arrange(group, score) %>% select(country, group, score),
  file.path(SAVE_DIR, "EXTREMES_10_90_members.csv")
)

# Tidy stacks for plotting
stacks_ext <- bind_rows(
  ext_wide %>% filter(component %in% c("Fiscal Support (share of all policies)",
                                       "Regulation (share of all policies)")) %>%
    mutate(dimension = "Instrument"),
  ext_wide %>% filter(component %in% c("Consumer (share of all policies)",
                                       "Non-Consumer (share of all policies)")) %>%
    mutate(dimension = "Targeting"),
  ext_wide %>% filter(component %in% c("Progressive (share of consumer policies)",
                                       "Regressive (share of consumer policies)")) %>%
    mutate(dimension = "Distribution (consumer)")
) %>%
  mutate(
    component = recode(component,
      "Fiscal Support (share of all policies)"   = "Fiscal Support",
      "Regulation (share of all policies)"       = "Regulation",
      "Consumer (share of all policies)"         = "Consumer",
      "Non-Consumer (share of all policies)"     = "Non-Consumer",
      "Progressive (share of consumer policies)" = "Progressive",
      "Regressive (share of consumer policies)"  = "Regressive"
    )
  ) %>%
  pivot_longer(c(`Bottom (weaker)`,`Top (stronger)`),
               names_to = "group", values_to = "share") %>%
  group_by(dimension, group) %>%
  mutate(share_norm = share / sum(share, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(
    dimension = factor(dimension, levels = c("Instrument","Targeting","Distribution (consumer)")),
    group = factor(group, levels = c("Bottom (weaker)","Top (stronger)")),
    component = factor(component, levels = c("Fiscal Support","Regulation","Consumer","Non-Consumer","Progressive","Regressive"))
  )

# Plot (Bottom)
p_bottom <- ggplot(stacks_ext, aes(x = group, y = share_norm, fill = component)) +
  geom_col(width = 0.72, color = "white", linewidth = 0.25) +
  geom_text(aes(label = ifelse(share_norm >= .06, percent(share_norm, 1), "")),
            position = position_stack(vjust = 0.5), size = 3, color = "white") +
  facet_wrap(~ dimension, nrow = 1) +
  scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0,1)) +
  scale_fill_manual(values = fill_map, name = NULL) +
  labs(
    title = "Extremes (p10/p90): normalized 3Ã—100% stacks",
    subtitle = "Each column sums to 100%. Top = stronger emission decline; Bottom = weaker.",
    x = NULL, y = "Share (100% per column)"
  ) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "top", panel.grid.major.x = element_blank(),
        strip.text = element_text(face = "bold"))

# =========================================================
# COMBINE & EXPORT (A4 portrait)
# =========================================================
final <- (p_top / p_bottom) +
  plot_annotation(
    title = "High vs Low emission-decline profiles â€” similarity and shifts across three policy dimensions",
    theme = theme(plot.title = element_text(face = "bold"))
  )

ggsave(file.path(SAVE_DIR, "A4_HvsL_DOUBLE.pdf"),
       final, width = 8.27, height = 11.69, units = "in")

message("âœ“ Created A4_HvsL_DOUBLE.pdf and CSVs:
- HvsL_mediansplit_CIs_long.csv
- HvsL_mediansplit_CIs_wide.csv
- HvsL_mediansplit_bin_sizes.csv
- HvsL_bootstrap_diffs.csv
- EXTREMES_10_90_table.csv
- EXTREMES_10_90_members.csv")
```


#### Durschnitts CO2

```{r ghg_pc_latest_year}
# =========================================================
# Lokale Berechnung der Pro-Kopf-Emissionen im jeweils
# letzten verfÃ¼gbaren Jahr (unabhÃ¤ngig von globalem END_YEAR)
#  - liest PRIMAP "roh" ein
#  - baut eigenes emiss_df_latest ohne year <= END_YEAR-Cut
#  - holt passende WDI-BevÃ¶lkerungsdaten bis zum letzten Jahr
#  - berechnet ungewichteten & bevÃ¶lkerungsgewichteten Schnitt
# =========================================================

suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(readr); library(WDI)
  library(janitor); library(stringr); library(countrycode)
})

# --- 0) PRIMAP roh einlesen ---
df_raw_latest <- readr::read_csv(PRIMAP_CSV, show_col_types = FALSE)

# --- 1) Filter auf M.0.EL / HISTCR / KYOTOGHG+CO2 wie oben ---
df_filt_latest <- df_raw_latest %>%
  dplyr::filter(
    `category (IPCC2006_PRIMAP)` == "M.0.EL",
    `scenario (PRIMAP-hist)` == "HISTCR",
    entity %in% c("KYOTOGHG (AR6GWP100)", "CO2")
  )

# --- 2) Long, aber OHNE year <= END_YEAR, nur untere Grenze ---
df_long_latest <- df_filt_latest %>%
  tidyr::pivot_longer(
    cols      = dplyr::matches("^[0-9]{4}$"),
    names_to  = "year",
    values_to = "emissions"
  ) %>%
  dplyr::mutate(year = as.integer(year)) %>%
  dplyr::filter(year >= START_YEAR)

# --- 3) ISO3-Subset + Wide â†’ emiss_df_latest ---
df_subset_latest <- df_long_latest %>%
  dplyr::filter(`area (ISO3)` %in% my_iso3)

df_wide_latest <- df_subset_latest %>%
  dplyr::select(`area (ISO3)`, year, entity, emissions) %>%
  tidyr::pivot_wider(names_from = entity, values_from = emissions) %>%
  dplyr::rename(
    iso3      = `area (ISO3)`,
    ghg_total = `KYOTOGHG (AR6GWP100)`,
    co2       = CO2
  ) %>%
  dplyr::arrange(iso3, year) %>%
  dplyr::mutate(
    country = countrycode(
      iso3, origin = "iso3c", destination = "country.name",
      warn = TRUE,
      custom_match = c("XKX"="Kosovo","EUU"="European Union","WLD"="World")
    ),
    country = norm_country(country)
  ) %>%
  dplyr::relocate(country, .after = iso3)

emiss_df_latest <- df_wide_latest %>%
  dplyr::select(country, year, ghg_total, co2)

# --- 4) Letztes PRIMAP-Jahr bestimmen ---
latest_year_primap <- emiss_df_latest %>%
  dplyr::filter(is.finite(ghg_total)) %>%
  dplyr::summarise(latest = max(year, na.rm = TRUE)) %>%
  dplyr::pull(latest)

cat("Letztes Jahr in PRIMAP (fÃ¼r deine 23 LÃ¤nder):", latest_year_primap, "\n")

# --- 5) WDI-BevÃ¶lkerung bis zu diesem Jahr laden (unabhÃ¤ngig von globalem END_YEAR) ---
wdi_raw_latest <- WDI(
  country   = "all",
  indicator = c("SP.POP.TOTL", "NY.GDP.MKTP.KD"),
  start     = START_YEAR,
  end       = latest_year_primap,
  extra     = TRUE,
  cache     = NULL
) %>% clean_names()

wdi_filtered_latest <- wdi_raw_latest %>%
  dplyr::transmute(
    country      = norm_country(country),
    iso3         = iso3c,
    region       = region,
    year         = year,
    population   = sp_pop_totl,
    gdp_constant = ny_gdp_mktp_kd
  ) %>%
  dplyr::filter(!is.na(region), region != "Aggregates") %>%
  dplyr::semi_join(countries_ref, by = "country")

# --- 6) Lokale Version von emiss_prepped, OHNE year <= END_YEAR ---
emiss_prepped_latest <- emiss_df_latest %>%
  dplyr::mutate(country = norm_country(country)) %>%
  dplyr::left_join(
    wdi_filtered_latest %>% dplyr::select(country, year, population),
    by = c("country","year")
  ) %>%
  dplyr::left_join(
    wdi_filtered_latest %>% dplyr::select(country, year, gdp_constant),
    by = c("country","year")
  ) %>%
  dplyr::mutate(
    ghg_pc     = dplyr::if_else(
      is.finite(ghg_total) & is.finite(population) & population > 0,
      ghg_total / population,
      NA_real_
    ),
    log_ghg_pc = log(ghg_pc)
  ) %>%
  dplyr::arrange(country, year)

# --- 7) Wirklich letztes Jahr mit Pro-Kopf-Emissionen ---
latest_year <- emiss_prepped_latest %>%
  dplyr::filter(is.finite(ghg_pc)) %>%
  dplyr::summarise(latest = max(year, na.rm = TRUE)) %>%
  dplyr::pull(latest)

cat("Neuester Jahrgang mit Pro-Kopf-Emissionen (lokal berechnet):", latest_year, "\n\n")

# --- 8) LÃ¤ndertabelle fÃ¼r dieses Jahr ---
ghg_pc_latest_tbl <- emiss_prepped_latest %>%
  dplyr::filter(year == latest_year, is.finite(ghg_pc)) %>%
  dplyr::select(country, year, ghg_total, population, ghg_pc) %>%
  dplyr::arrange(dplyr::desc(ghg_pc))

# --- 9) Ungewichteter und bevÃ¶lkerungsgewichteter Durchschnitt ---
mean_ghg_pc_unweighted <- mean(ghg_pc_latest_tbl$ghg_pc, na.rm = TRUE)

totals_latest <- ghg_pc_latest_tbl %>%
  dplyr::summarise(
    total_emissions  = sum(ghg_total,  na.rm = TRUE),
    total_population = sum(population, na.rm = TRUE)
  ) %>%
  dplyr::mutate(
    mean_ghg_pc_weighted = dplyr::if_else(
      total_population > 0,
      total_emissions / total_population,
      NA_real_
    )
  )

mean_ghg_pc_weighted <- totals_latest$mean_ghg_pc_weighted

mean_summary <- tibble::tibble(
  year                     = latest_year,
  mean_ghg_pc_unweighted   = mean_ghg_pc_unweighted,
  mean_ghg_pc_weighted_all = mean_ghg_pc_weighted
)

# Ausgabe (noch in Gg/Person; fÃ¼r tCO2e/Kopf Ã—1000 nehmen):
mean_summary
ghg_pc_latest_tbl
```


```{r ghg_pc_latest_year}
# =========================================================
# Durchschnittliche Pro-Kopf-Emissionen im neuesten Jahr
#  - LÃ¤ndertabelle
#  - Ungewichteter & bevÃ¶lkerungsgewichteter Durchschnitt
#    (Summe Emissionen / Summe BevÃ¶lkerung)
# Variante: "emiss_prepped_latest" ignoriert den globalen END_YEAR-Cut
# =========================================================

# 0) Lokale Version von emiss_prepped, OHNE year <= END_YEAR
emiss_prepped_latest <- emiss_df %>%
  dplyr::mutate(country = norm_country(country)) %>%
  dplyr::left_join(
    wdi_filtered %>% dplyr::select(country, year, population),
    by = c("country","year")
  ) %>%
  dplyr::left_join(
    wdi_filtered %>% dplyr::select(country, year, gdp_constant),
    by = c("country","year")
  ) %>%
  # Nur untere Grenze beachten (START_YEAR), kein Cut bei END_YEAR
  dplyr::filter(year >= START_YEAR) %>%
  dplyr::mutate(
    ghg_pc     = dplyr::if_else(
      is.finite(ghg_total) & is.finite(population) & population > 0,
      ghg_total / population,
      NA_real_
    ),
    log_ghg_pc = log(ghg_pc)
  ) %>%
  dplyr::arrange(country, year)

# 1) Neuestes Jahr mit vorhandenen Pro-Kopf-Emissionen ermitteln
latest_year <- emiss_prepped_latest %>%
  dplyr::filter(is.finite(ghg_pc)) %>%
  dplyr::summarise(latest = max(year, na.rm = TRUE)) %>%
  dplyr::pull(latest)

cat("Neuester Jahrgang mit Pro-Kopf-Emissionen im Datensatz:", latest_year, "\n\n")


# 2) LÃ¤ndertabelle fÃ¼r dieses Jahr
ghg_pc_latest_tbl <- emiss_prepped %>%
  dplyr::filter(year == latest_year, is.finite(ghg_pc)) %>%
  dplyr::select(country, year, ghg_total, population, ghg_pc) %>%
  dplyr::arrange(dplyr::desc(ghg_pc))

# 3) Ungewichteter Durchschnitt Ã¼ber LÃ¤nder
mean_ghg_pc_unweighted <- mean(ghg_pc_latest_tbl$ghg_pc, na.rm = TRUE)

# 4) BevÃ¶lkerungsgewichteter Durchschnitt:
#    (alle Emissionen zusammen) / (alle Einwohner zusammen)
totals_latest <- ghg_pc_latest_tbl %>%
  dplyr::summarise(
    total_emissions   = sum(ghg_total, na.rm = TRUE),
    total_population  = sum(population, na.rm = TRUE)
  ) %>%
  dplyr::mutate(
    mean_ghg_pc_weighted = dplyr::if_else(
      total_population > 0,
      total_emissions / total_population,
      NA_real_
    )
  )

mean_ghg_pc_weighted <- totals_latest$mean_ghg_pc_weighted

# 5) Kompakte Ãœbersicht der beiden Durchschnitte
mean_summary <- tibble::tibble(
  year                     = latest_year,
  mean_ghg_pc_unweighted   = mean_ghg_pc_unweighted,
  mean_ghg_pc_weighted_all = mean_ghg_pc_weighted
)

# Ausgabe:
mean_summary      # 1 Zeile: beide Durchschnitte fÃ¼r das neueste Jahr
ghg_pc_latest_tbl # Tabelle: einzelne LÃ¤nder
```

